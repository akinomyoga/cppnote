<!DOCTYPE html>
<html>
<head>
  <title>N4659</title>
  <meta charset="utf-8" />
  <style>
  body{max-width: 60em; margin-left: auto; margin-right: auto; text-align: justify}
  @media print { body {font-family: "Times New Roman", serif;} }

  pre, code {font-family: monospace, serif;} /* to adjust monospace font-size */
  @media print { pre, code {font-family: "Courier New", monospace;} }

  /* section headings */
  h1, h2, h3, h4, h5, h6 {position: relative;}
  h1:has(>span.stag),
  h2:has(>span.stag),
  h3:has(>span.stag),
  h4:has(>span.stag),
  h5:has(>span.stag),
  h6:has(>span.stag) {padding-right: 10em;} /* Note: :has() pseudo-class comes with CSS Level 4 */
  span.stag {position: absolute; right: 0;}
  h1 {font-size: 2.0em;}
  h2, h3 {font-size: 1.5em;}
  h4, h5, h6 {font-size: 1.15em;}

  span.ptag{color: green; font-weight: bold; vertical-align: super; font-size: 80%; margin-right: 0.1em;}

  p.en, div.en{background-color: #eec; padding: 0.8em;}
  p.en:before, div.en:before{content: "原文 "; font-weight: bold;}

  /*p.translation-note{border:1px solid gray;padding:0.5em;}*/
  .translation-note{background-color: #ddd; padding: 0.8em; margin-bottom: 0.8em;}
  .translation-note:before{content: "訳註: "; font-weight: bold;}

  dfn {font-style: normal; font-weight: bold;}
  @media print{ dfn {font-family: sans-serif; font-weight: normal;} }

  div.syntax {margin-left: 2em;}
  span.syntax {color: purple; font-style: italic;}
  div.syntax sub.opt {color: blue; font-style: italic;}
  @media print { div.syntax i {font-family: "Times New Roman", serif;} }

  span.tcomment {color: green;}
  span.tcomment:before {content: "[訳者: ";}
  span.tcomment:after {content: "]";}

  i, span.syntax, div.syntax sub.opt
  {margin-left: 0.05em; margin-right:0.05em; position: relative; left: -0.1em;} /* イタリック補正 */


  table.normal {border-collapse: collapse; margin: 0.8em auto;}
  table.normal>caption {margin: 0.4em;}
  table.normal>*>tr>td,
  table.normal>*>tr>th {border: 1px solid black; padding: 0.4em;}
  </style>
  <meta name="agh-fly-type" content="color" />
  <script src="https://akinomyoga.github.io/agh/agh.fly.js" charset="utf-8"></script>
</head>
<body>
<h1>Working Draft, Standard for Programming Language C++</h1>
<p>略</p>

<p class="translation-note">
この訳では、自然な日本語になるように、
規格としての意味が変わらない範囲で適宜文の構造を変えるなどしている。
例えば、長い文を2つに分ける、日本語として冗長な表現を排するなどのことをしている。
</p>
<div class="translation-note">
  訳語について
  <ul>
  <li>access rule → アクセス規則</li>
  <li>type-specifier → 型指定子</li>
  <li>visible → 可視の</li>
  <li>invocation, call → 呼び出し (両者は今のところ日本語では区別しない)</li>
  <li>accessibility of the function → 関数のアクセス可能性</li>
  <li>pointer-to-function → 関数ポインタ</li>
  <li>reference-to-function → 関数の参照</li>
  <li>reference-to-pointer-to-function → 関数ポインタの参照</li>
  <li>default-initialization → 既定初期化</li>
  <li>direct-initialization → 直接初期化</li>
  <li>copy-initialization → コピー初期化</li>
  <li>underlying type → 基礎型 (JIS C++ では基礎となる型としている。中国語では基礎型のようだ)</li>
  <li>storage class → 記憶域クラス (JIS C++ では記憶域種別としている)</li>
  <li>alignment → アライメント (JIS C++ では境界調整としている)</li>
  <li>defaulted functions → 既定化された関数</li>
  <li>deleted functions → 削除された関数</li>
  <li>ref-qualifier → ref 修飾子 (当初、参照修飾子としたが、"ref" 自体が省略なのでこれをそのまま採用する)</li>
  <li>《多重定義関連》
    <ul>
    <li>overload → 多重定義する</li>
    <li>overloaded declarations → 多重定義 (実は多重宣言の方が適切な気がするが多重定義とするのが一般的である)</li>
    <li>viable functions → 呼び出し可能関数 (JIS C++ では二次候補関数としている)</li>
    <li>implicit conversion sequence → 暗黙変換列 (JIS C++ では暗黙の変換手順としている)</li>
    <li>implicit object paramter → 暗黙オブジェクト仮引数</li>
    <li>implied object argument → 暗黙オブジェクト実引数</li>
    <li>named function/class → 名前の指定された関数・クラス (JIS C++ では名前のある関数としている)</li>
    <li>qualified/unqualified function calls → 修飾付き・修飾なし関数呼び出し (JIS C++ では 修飾付き・修飾なしの関数呼出しとしている)</li>
    </ul>
  </li>
  <li>sequenced → 副作用完了する (字義通りには「順序付けられる」だが C/C++ の sequence point の訳語に倣う)</li>
  </ul>
</div>

<h1>Contents</h1>
<p>略</p>

<h1>List of Tables</h1>
<p>略</p>

<h1>List of Figures</h1>
<p>略</p>

<h1 id="sec1">1 Scope <span class="stag">[intro.scope]</span></h1>
<p><span class="ptag" id="sec1p1" title="1 [intro.scope]/1">1</span>
この文書は C++ プログラミング言語の処理系に対する要求を指定する。
第一の要求は処理系が言語を実装することであり、これはこの文書が C++ を定義するということを意味する。
その他の要求と、第一の要求の例外は、この文書の中で折に触れて述べる。
</p>
<p><span class="ptag" id="sec1p2" title="1 [intro.scope]/2">2</span>
C++ は 「ISO/IEC 9899:2011 Programming languates -- C」(以降 C 規格と呼ぶ) によって定義される C 言語を元にした汎用の言語である。
C によって提供される機能の他に、C++ は追加のデータ型、クラス、テンプレート、例外、名前空間、
演算子と関数の多重定義、参照、メモリ管理の演算子、追加のライブラリ機能を提供する。
</p>
<div class="en">
  <p><span class="ptag" title="1 [intro.scope]/1">1</span>
  This document specifies requirements for implementations of the C++ programming language. The first such
  requirement is that they implement the language, so this document also defines C++ . Other requirements
  and relaxations of the first requirement appear at various places within this document.
  </p>
  <p><span class="ptag" title="1 [intro.scope]/2">2</span>
  C++ is a general purpose programming language based on the C programming language as described in
  ISO/IEC 9899:2011 Programming languages — C (hereinafter referred to as the C standard). In addition to
  the facilities provided by C, C ++ provides additional data types, classes, templates, exceptions, namespaces,
  operator overloading, function name overloading, references, free store management operators, and additional
  library facilities.</p>
</div>
<p class="translation-note">
この部分は C++03 の時から更新されていない。
C++11 以降で追加されたメジャーな機能――例えばラムダ式などは追加しなくても良いのだろうか?
</p>

<h1 id="sec2">2 Normative references <span class="stag">[intro.refs]</span></h1>
<p><span class="ptag" id="sec2p1" title="2 [intro.refs]/1">1</span>
以下の文書は、その内容の一部または全ての内容がこの文書の要求を構成するものとして、この文書の本文から適宜参照される。
以下の文書で版が指定されている場合は、ここで参照した版のみが有効である。
版が指定されていない場合は、その文書の最新版 (訂正 (amendments) を含む) が有効である。
</p>
<ul>
<li><span class="ptag" id="sec2p1.1" title="2 [intro.refs]/(1.1)">(1.1)</span>
  Ecma International, <i>ECMAScript Language Specification</i>, Standard Ecma-262, third edition, 1999.</li>
<li><span class="ptag" id="sec2p1.2" title="2 [intro.refs]/(1.2)">(1.2)</span>
  ISO/IEC 2382 (all parts), <i>Information technology - Vocabulary</i></li>
<li><span class="ptag" id="sec2p1.3" title="2 [intro.refs]/(1.3)">(1.3)</span>
  ISO/IEC 9899:2011, <i>Programming languages - C</i></li>
<li><span class="ptag" id="sec2p1.4" title="2 [intro.refs]/(1.4)">(1.4)</span>
  ISO/IEC 9899:2011/Cor.1:2012(E), <i>Programming languages - C, Technical Corrigendum 1</i></li>
<li><span class="ptag" id="sec2p1.5" title="2 [intro.refs]/(1.5)">(1.5)</span>
  ISO/IEC 9945:2003, <i>Information Technology - Portable Operating System Interface (POSIX)</i></li>
<li><span class="ptag" id="sec2p1.6" title="2 [intro.refs]/(1.6)">(1.6)</span>
  ISO/IEC 10646-1:1993, <i>Information technology - Universal Multiple-Octet Coded Character Set (UCS) - Part 1: Architecture and Basic Multilingual Plane</i></li>
<li><span class="ptag" id="sec2p1.7" title="2 [intro.refs]/(1.7)">(1.7)</span>
  ISO/IEC 10967-1:2012, <i>Information technology - Language independent arithmetic - Part 1: Integer and floating point arithmetic</i></li>
<li><span class="ptag" id="sec2p1.8" title="2 [intro.refs]/(1.8)">(1.8)</span>
  ISO/IEC/IEEE 60559:2011, <i>Information technology - Microprocessor Systems - Floating-Point arithmetic</i></li>
<li><span class="ptag" id="sec2p1.9" title="2 [intro.refs]/(1.9)">(1.9)</span>
  ISO 80000-2:2009, <i>Quantities and units - Part 2: Mathematical signs and symbols to be used in the natural sciences and technology</i></li>
</ul>
<p><span class="ptag" id="sec2p2" title="2 [intro.refs]/2">2</span>
ISO/IEC 9899:2011 の Clause 7 で記述されるライブラリは、以降 <dfn>C 標準ライブラリ</dfn> (C standard library) と呼ぶ<sup>1</sup>。
</p>
<p><span class="ptag" id="sec2p3" title="2 [intro.refs]/3">3</span>
ISO/IEC 9945:2003 で記述される OS のインターフェイスは、以降 <dfn>POSIX</dfn> と呼ぶ。
</p>
<p><span class="ptag" id="sec2p4" title="2 [intro.refs]/4">4</span>
Ecma-262 標準で記述される ECMAScript 言語仕様は、以降 <dfn>ECMA-262</dfn> と呼ぶ。
</p>
<p><span class="ptag" id="sec2p5" title="2 [intro.refs]/5">5</span>
ISO/IEC 10967-1:2012 で記述される算術仕様は、以降 <dfn>LIA-1</dfn> と呼ぶ。
</p>
<p><span class="ptag" id="footnote1">footnote 1</span>
C.5 の Clause 21 から 33 までの但し書き付きで、
C 標準ライブラリは C++ 標準ライブラリの部分集合である。
</p>
<div class="en">
  <p><span class="ptag" title="2 [intro.refs]/1">1</span>
  The following documents are referred to in the text in such a way that some or all of their content constitutes
  requirements of this document. For dated references, only the edition cited applies. For undated references,
  the latest edition of the referenced document (including any amendments) applies.
  </p>
  <ul>
  <li><span class="ptag" title="2 [intro.refs]/(1.1)">(1.1)</span>
    Ecma International, ECMAScript Language Specification, Standard Ecma-262, third edition, 1999.</li>
  <li><span class="ptag" title="2 [intro.refs]/(1.2)">(1.2)</span>
    ISO/IEC 2382 (all parts), Information technology — Vocabulary</li>
  <li><span class="ptag" title="2 [intro.refs]/(1.3)">(1.3)</span>
    ISO/IEC 9899:2011, Programming languages — C</li>
  <li><span class="ptag" title="2 [intro.refs]/(1.4)">(1.4)</span>
    ISO/IEC 9899:2011/Cor.1:2012(E), Programming languages — C, Technical Corrigendum 1</li>
  <li><span class="ptag" title="2 [intro.refs]/(1.5)">(1.5)</span>
    ISO/IEC 9945:2003, Information Technology — Portable Operating System Interface (POSIX)</li>
  <li><span class="ptag" title="2 [intro.refs]/(1.6)">(1.6)</span>
    ISO/IEC 10646-1:1993, Information technology — Universal Multiple-Octet Coded Character Set (UCS) — Part 1: Architecture and Basic Multilingual Plane</li>
  <li><span class="ptag" title="2 [intro.refs]/(1.7)">(1.7)</span>
    ISO/IEC 10967-1:2012, Information technology — Language independent arithmetic — Part 1: Integer and floating point arithmetic</li>
  <li><span class="ptag" title="2 [intro.refs]/(1.8)">(1.8)</span>
    ISO/IEC/IEEE 60559:2011, Information technology — Microprocessor Systems — Floating-Point arithmetic</li>
  <li><span class="ptag" title="2 [intro.refs]/(1.9)">(1.9)</span>
    ISO 80000-2:2009, Quantities and units — Part 2: Mathematical signs and symbols to be used in the natural sciences and technology</li>
  </ul>
  <p><span class="ptag" title="2 [intro.refs]/2">2</span>
  The library described in Clause 7 of ISO/IEC 9899:2011 is hereinafter called the C standard library<sup>1</sup>.
  </p>
  <p><span class="ptag" title="2 [intro.refs]/3">3</span>
  The operating system interface described in ISO/IEC 9945:2003 is hereinafter called POSIX.
  </p>
  <p><span class="ptag" title="2 [intro.refs]/4">4</span>
  The ECMAScript Language Specification described in Standard Ecma-262 is hereinafter called ECMA-262.
  </p>
  <p><span class="ptag" title="2 [intro.refs]/5">5</span>
  The arithmetic specification described in ISO/IEC 10967-1:2012 is hereinafter called LIA-1.
  </p>
  <p><span class="ptag">footnote 1</span>
  With the qualifications noted in Clauses 21 through 33 and in C.5, the C standard library is a subset of the C ++ standard
  library.
  </p>
</div>

<h1 id="sec3">3 Terms and definitions <span class="stag">[intro.defs]</span></h1>
<p><span class="ptag" id="sec3p1" title="3 [intro.defs]/1">1</span>
この文書の説明のため、
ISO/IEC 2382-1:1993 で与えられる用語と定義、
ISO 80000-2:2009 で与えられる用語と定義と記号、
更に次のものが適用される。
</p>
<p><span class="ptag" id="sec3p2" title="3 [intro.defs]/2">2</span>
ISO と IEC は、標準規格で使うことを目的として用語のデータベースを次の URL で管理している。
</p>
<ul>
<li><span class="ptag" id="sec3p2.1" title="3 [intro.defs]/(2.1)">(2.1)</span>
  IEC Electropedia: http://www.electropedia.org/ で利用可能</li>
<li><span class="ptag" id="sec3p2.2" title="3 [intro.defs]/(2.2)">(2.2)</span>
  ISO Online browsing platform: http://www.iso.org/obp で利用可能</li>
</ul>
<p><span class="ptag" id="sec3p3" title="3 [intro.defs]/3">3</span>
Clause 20 から 33 と補遺 D で使用される追加の用語が、20.3 で定義される。
</p>
<p><span class="ptag" id="sec3p4" title="3 [intro.defs]/4">4</span>
この文書の極一部で使われる用語は、その使用箇所で斜体で定義される。
</p>

<div class="en">
  <p><span class="ptag" title="3 [intro.defs]/1">1</span>
  For the purposes of this document, the terms and definitions given in ISO/IEC 2382-1:1993, the terms,
  definitions, and symbols given in ISO 80000-2:2009, and the following apply.
  </p>
  <p><span class="ptag" title="3 [intro.defs]/2">2</span>
  ISO and IEC maintain terminological databases for use in standardization at the following addresses:
  </p>
  <ul>
  <li><span class="ptag" title="3 [intro.defs]/(2.1)">(2.1)</span>
    IEC Electropedia: available at http://www.electropedia.org/</li>
  <li><span class="ptag" title="3 [intro.defs]/(2.2)">(2.2)</span>
    ISO Online browsing platform: available at http://www.iso.org/obp</li>
  </ul>
  <p><span class="ptag" title="3 [intro.defs]/3">3</span>
  20.3 defines additional terms that are used only in Clauses 20 through 33 and Annex D.
  </p>
  <p><span class="ptag" title="3 [intro.defs]/4">4</span>
  Terms that are used only in a small portion of this document are defined where they are used and italicized
  where they are defined.
  </p>
</div>

<h2 id="sec3.1">3.1 access <span class="stag">[defns.access]</span></h2>
<p>《実行時の動作》 オブジェクトの値を読み取るか修正すること</p>
<p class="en">〈execution-time action〉 to read or modify the value of an object</p>

<h2 id="sec3.2">3.2 argument <span class="stag">[defns.argument]</span></h2>
<p>《関数呼び出し式》 丸括弧で囲まれたカンマ区切りのリストに含まれる式 (8.2.2)</p>
<p class="en">〈function call expression〉 expression in the comma-separated list bounded by the parentheses (8.2.2)</p>

<h2 id="sec3.3">3.3 argument <span class="stag">[defns.argument.macro]</span></h2>
<p>《関数マクロ》 丸括弧で囲まれたカンマ区切りのリストに含まれるプリプロセッサトークンの列 (19.3)</p>
<p class="en">〈function-like macro〉 sequence of preprocessing tokens in the comma-separated list bounded by the parentheses (19.3)</p>

<h2 id="sec3.4">3.4 argument <span class="stag">[defns.argument.throw]</span></h2>
<p>《例外スロー式》 <code class="agh-prog-cpp">throw</code> の対象 (8.17)</p>
<p class="en">〈throw expression〉 the operand of <code class="agh-prog-cpp">throw</code> (8.17)</p>

<h2 id="sec3.5">3.5 argument <span class="stag">[defns.argument.templ]</span></h2>
<p>《テンプレート実体化》 角括弧で囲まれたカンマ区切りのリストに含まれる
<span class="syntax">constant-expression</span>、<span class="syntax">type-id</span>、または <span class="syntax">id-expression</span> (17.3)</p>
<p class="en">〈template instantiation〉 constant-expression, type-id, or id-expression in the comma-separated list bounded by the angle brackets (17.3)</p>

<h2>3.* 略</h2>

<h1 id="sec4">4 略</h1>
<h1 id="sec5">5 略</h1>
<h1 id="sec6">6 略</h1>
<h1 id="sec7">7 略</h1>
<h1 id="sec8">8 略</h1>
<h1 id="sec9">9 略</h1>
<h1 id="sec10">10 略</h1>
<h1 id="sec11">11 Declarators <span class="stag">[dcl.decl]</span></h1>
<h2 id="sec11.1">11.1 Type names <span class="stag">[dcl.name]</span></h2>
<h2 id="sec11.2">11.2 Ambiguity resolution <span class="stag">[dcl.ambig.res]</span></h2>
<h2 id="sec11.3">11.3 Meaning of declarators <span class="stag">[dcl.meaning]</span></h2>
<h2 id="sec11.4">11.4 Function definitions <span class="stag">[dcl.fct.def]</span></h2>
<h2 id="sec11.5">11.5 Structured binding declarations <span class="stag">[dcl.struct.bind]</span></h2>
<h2 id="sec11.6">11.6 Initializers <span class="stag">[dcl.init]</span></h2>
<p>■16.3, 17.6, 17.8 のあと</p>
<h1 id="sec12">12 略</h1>
<h1 id="sec13">13 略</h1>
<h1 id="sec14">14 略</h1>
<h1 id="sec15">15 略</h1>
<h1 id="sec16">16 Overloading <span class="stag">[over]</span></h1>
<p><span class="ptag" id="sec16p1" title="16 [over]/1">1</span> 同じスコープで一つの名前について2つ以上の宣言が指定された時、その名前は<dfn>多重定義</dfn> (overload) されているという。
更に、同じスコープで同じ名前だが異なる型の二つの宣言を<dfn>多重定義</dfn> (overloaded declaration) と呼ぶ。
関数および関数テンプレートの宣言のみが多重定義されうる。
つまり、変数と型の宣言は多重定義できない。
</p>
<p><span class="ptag" id="sec16p2" title="16 [over]/2">2</span> 多重定義された関数名が呼び出しで使われた時、
関数の多重定義の内どれが用いられるかは、
実引数の型とその時点で可視の多重定義の仮引数の型を比較することによって決定される。
関数を選択する手続きは<dfn>多重定義解決</dfn> (overload resolution) と呼び 16.3 で定義される。[例:
</p>
<pre class="agh-prog-cpp">
double abs(double);
int abs(int);

abs(1); // abs(int); が呼び出される
abs(1.0); // abs(double); が呼び出される
</pre>
<p>- 例終わり ]</p>
<div class="en">
  <p><span class="ptag" title="16 [over]/1">1</span>
  When two or more different declarations are specified for a single name in the same scope, that name is said
  to be overloaded. By extension, two declarations in the same scope that declare the same name but with
  different types are called overloaded declarations. Only function and function template declarations can be
  overloaded; variable and type declarations cannot be overloaded.
  </p>
  <p><span class="ptag" title="16 [over]/2">2</span>
  When an overloaded function name is used in a call, which overloaded function declaration is being referenced
  is determined by comparing the types of the arguments at the point of use with the types of the parameters
  in the overloaded declarations that are visible at the point of use. This function selection process is called
  overload resolution and is defined in 16.3. [Example:
  </p>
<pre class="agh-prog-cpp">
double abs(double);
int abs(int);

abs(1); // calls abs(int);
abs(1.0); // calls abs(double);
</pre>
  <p>-- end example]</p>
</div>

<h2 id="sec16.1">16.1 Overloadable declarations <span class="stag">[over.load]</span></h2>
<p><span class="ptag" id="sec16.1p1" title="16.1 [over.load]/1">1</span>
全ての関数宣言が多重定義できるわけではない。
多重定義できないものをここで指定する。
同じスコープに多重定義できない宣言の組を含むプログラムは不適格である。
[註: この制限は、そのスコープにおける明示的宣言同士、または明示宣言と using 宣言により導入される宣言の間に適用される。
(using 指令などに基づく) 名前解決や、 (演算子関数などの) 多重定義解決の過程で考慮される関数の集合に対しては適用されない。 - 註終わり ]
</p>
<p><span class="ptag" id="sec16.1p2" title="16.1 [over.load]/2">2</span> 一部の関数宣言は多重定義できない:</p>
<ul>
<li><span class="ptag" id="sec16.1p2.1" title="16.1 [over.load]/(2.1)">(2.1)</span>
  戻り値の型、例外指定子 (18.4) を除いて一致する関数宣言は多重定義できない。</li>
<li><span class="ptag" id="sec16.1p2.2" title="16.1 [over.load]/(2.2)">(2.2)</span>
  同名で同じ仮引数リスト (11.3.5) を持つメンバ関数宣言は、
  その内の一つが静的メンバ関数宣言 (12.2.3) であるとき、多重定義できない。
  同様に、同名で同じ仮引数リスト、同じテンプレート仮引数リストを持つメンバ関数テンプレート宣言は、
  その内の一つが静的メンバ関数テンプレート宣言であるとき、多重定義できない。
  この規則で仮引数リストを比較する際、多重定義解決のために導入される暗黙オブジェクト仮引数 (16.3.1) の型は考慮されない。
  一方で、静的メンバ関数宣言が含まれない場合は、暗黙オブジェクト仮引数が異なる関数宣言を多重定義できる。
  [例: この違いを以下のコードに示す:
<pre class="agh-prog-cpp">
class X {
  static void f();
  void f();                 // 不適格
  void f() const;           // 不適格
  void f() const volatile;  // 不適格
  void g();
  void g() const;           // OK: 静的な g がないので
  void g() const volatile;  // OK: 静的な g がないので
};
</pre>
  - 例終わり ]
  </li>
<li><span class="ptag" id="sec16.1p2.3" title="16.1 [over.load]/(2.3)">(2.3)</span>
  同名・同じ仮引数リストを持つメンバ関数宣言と、
  同名・同じ仮引数リスト・同じテンプレート仮引数リストを持つメンバ関数テンプレートは、
  その内 1 つでも ref 修飾子を持っている場合、
  全てが ref 修飾子を持っていなければ多重定義できない。
  [例:
<pre class="agh-prog-cpp">
class Y {
  void h() &amp;;
  void h() const &amp;; // OK
  void h() &amp;&amp;;      // OK, 全ての宣言が ref 修飾子を持つ。
  void i() &amp;;
  void i() const;   // 不適格。前の i の宣言は ref 修飾子を持つ。
};
  </pre>
  - 例終わり ]
  </li>
</ul>

<div class="en">
  <p><span class="ptag" title="16.1 [over.load]/1">1</span>
  Not all function declarations can be overloaded. Those that cannot be overloaded are specified here. A
  program is ill-formed if it contains two such non-overloadable declarations in the same scope. [Note: This
  restriction applies to explicit declarations in a scope, and between such declarations and declarations made
  through a using-declaration (10.3.3). It does not apply to sets of functions fabricated as a result of name
  lookup (e.g., because of using-directives) or overload resolution (e.g., for operator functions). - end note ]
  </p>
  <p><span class="ptag" title="16.1 [over.load]/2">2</span>
  Certain function declarations cannot be overloaded:
  </p>
  <ul>
  <li><span class="ptag" title="16.1 [over.load]/(2.1)">(2.1)</span>
    Function declarations that differ only in the return type, the exception specification (18.4), or both
    cannot be overloaded.</li>
  <li><span class="ptag" title="16.1 [over.load]/(2.2)">(2.2)</span>
    Member function declarations with the same name and the same parameter-type-list (11.3.5) cannot be
    overloaded if any of them is a static member function declaration (12.2.3). Likewise, member function
    template declarations with the same name, the same parameter-type-list, and the same template
    parameter lists cannot be overloaded if any of them is a static member function template declaration.
    The types of the implicit object parameters constructed for the member functions for the purpose of
    overload resolution (16.3.1) are not considered when comparing parameter-type-lists for enforcement
    of this rule. In contrast, if there is no static member function declaration among a set of member
    function declarations with the same name and the same parameter-type-list, then these member function
    declarations can be overloaded if they differ in the type of their implicit object parameter. [Example:
    The following illustrates this distinction:
<pre class="agh-prog-cpp">
class X {
  static void f();
  void f();                 // ill-formed
  void f() const;           // ill-formed
  void f() const volatile;  // ill-formed
  void g();
  void g() const;           // OK: no static g
  void g() const volatile;  // OK: no static g
};
</pre>
    —end example ]
    </li>
  <li><span class="ptag" title="16.1 [over.load]/(2.3)">(2.3)</span> Member function declarations with the same name and the same parameter-type-list (11.3.5) as well as
    member function template declarations with the same name, the same parameter-type-list, and the same
    template parameter lists cannot be overloaded if any of them, but not all, have a ref-qualifier (11.3.5).
    [Example:
<pre class="agh-prog-cpp">
class Y {
  void h() &amp;;
  void h() const &amp;; // OK
  void h() &amp;&amp;;      // OK, all declarations have a ref-qualifier
  void i() &amp;;
  void i() const;   // ill-formed, prior declaration of i
                    // has a ref-qualifier
};
</pre>
    —end example ]
    </li>
  </ul>
</div>

<p><span class="ptag" id="sec16.1p3" title="16.1 [over.load]/3">3</span>
[註: 11.3.5 で指定したように、関数宣言の組が等価な仮引数宣言を持つ場合、
これらは同じ関数を宣言することになるので多重定義することはできない。
</p>
<ul>
<li><span class="ptag" id="sec16.1p3.1" title="16.1 [over.load]/(3.1)">(3.1)</span> 等価な typedef された型を使っている点だけ異なる仮引数宣言は等価である。
typedef は独立した型ではなく、ただ他の型の別名を与えるに過ぎない (10.1.3)。[例:
<pre class="agh-prog-cpp">
typedef int Int;
void f(int i);
void f(Int i);              // OK: f(int) の再宣言
void f(int i) { /* ... */ }
void f(Int i) { /* ... */ } // error: f(int) の再定義
</pre>
  - 例終わり ]
  一方で列挙型は独立した型であり、関数の異なる多重定義を与える。
  [例:
<pre class="agh-prog-cpp">
enum E { a };
void f(int i) { /* ... */ }
void f(E i) { /* ... */ }
</pre>
  - 例終わり ]
  </li>
<li><span class="ptag" id="sec16.1p3.2" title="16.1 [over.load]/(3.2)">(3.2)</span>
  一方がポインタ * であり他方が配列 [] であるという点のみ異なる仮引数宣言は等価である。
  即ち、配列宣言はポインタ宣言に調整 (11.3.5) されるためである。
  2番目以降の配列の次元のみが仮引数の型において意味を持つ (11.3.4)。[例:
<pre class="agh-prog-cpp">
int f(char*);
int f(char[]);      // f(char*); と同じ
int f(char[7]);     // f(char*); と同じ
int f(char[9]);     // f(char*); と同じ
int g(char(*)[10]);
int g(char[5][10]); // g(char(*)[10]); と同じ
int g(char[7][10]); // g(char(*)[10]); と同じ
int g(char(*)[20]); // g(char(*)[10]); とは異なる。
</pre>
  - 例終わり ]
  </li>
<li><span class="ptag" id="sec16.1p3.3" title="16.1 [over.load]/(3.3)">(3.3)</span>
  一方が関数型であり他方が同じ関数型へのポインタであるという点のみ異なる仮引数宣言は等価である。
  即ち、関数型は関数型へのポインタへと調整 (11.3.5) されるためである。[例:
<pre class="agh-prog-cpp">
void h(int());
void h(int (*)());      // h(int()) の再宣言
void h(int x()) { }     // h(int()) の定義
void h(int (*x)()) { }  // 不適格: h(int()) の再定義
</pre>
  - 例終わり ]
  </li>
<li><span class="ptag" id="sec16.1p3.4" title="16.1 [over.load]/(3.4)">(3.4)</span>
  const または volatile が存在するかどうかのみが異なる仮引数宣言は等価である。
  即ち、どの関数型が宣言されるか・定義されるか・呼び出されるかを決定する際に、
  仮引数型の const/volatile 型指定子は無視される。[例:
<pre class="agh-prog-cpp">
typedef const int cInt;
int f (int);
int f (const int);          // f(int) の再宣言
int f (int) { /* ... */ }   // f(int) の定義
int f (cInt) { /* ... */ }  // error: f(int) の再定義
</pre>
  - 例終わり ]
  仮引数型の一番外側の const/volatile 型指定子のみが、以下のように無視される。
  仮引数型の内部に埋め込まれた const/volatile 型指定子は、
  関数の多重定義を区別する上で意味を持つ<sup>123</sup>。
  特に、任意の型 <code class="agh-prog-cpp">T</code> について、<code class="agh-prog-cpp">T</code> へのポインタ、
  <code class="agh-prog-cpp">const T</code> へのポインタ、<code class="agh-prog-cpp">volatile T</code> へのポインタは、
  異なる仮引数型と解釈される。
  <code class="agh-prog-cpp">T</code> への参照、<code class="agh-prog-cpp">const T</code> への参照、
  <code class="agh-prog-cpp">volatile T</code> への参照についても同様である。
  </li>
<li><span class="ptag" id="sec16.1p3.5" title="16.1 [over.load]/(3.5)">(3.5)</span> 既定の実引数のみが相違する仮引数宣言は等価である。[例:
  以下の例を考慮されたい:
<pre class="agh-prog-cpp">
void f (int i, int j);
void f (int i, int j = 99); // OK: f(int, int) の再宣言
void f (int i = 88, int j); // OK: f(int, int) の再宣言
void f ();                  // OK: f の多重定義の宣言
void prog () {
  f (1, 2);                 // OK: f(int, int) の呼び出し
  f (1);                    // OK: f(int, int) の呼び出し
  f ();                     // Error: f(int, int) と f() のどちら?
}
</pre>
  - 例終わり ]
  </li>
</ul>
<p>- 註終わり ]</p>
<p><span class="ptag" id="footnote123">footnote 123</span>
仮引数型が関数型を含む場合 (例えば仮引数型が関数ポインタの場合)、
その内部関数型の仮引数型において最も外側の const/volatile 型指定子は無視される。</p>
<p class="translation-note">
この部分は Note に過ぎないので細かいことは気にしていないのかもしれないが、色々と記述に穴がある気がする。
例えば、differs only として項目を連ねているが、2つ以上の項目で異なる場合については述べていないので語弊がある。
また、内部関数型の仮引数の const/volatile 無視については述べているが typedef/配列型/関数型 については述べていない。
実際のコンパイラで試すと、期待通り typedef/配列型/関数型 も考慮に入れられるようなので、これはここの記述が分かりにくいだけだ。
思うに、〈仮引数の宣言型〉・〈仮引数の調整型〉・〈型の同一性〉のような概念を導入して統一的に定義するべきなのではという気がする。
</p>

<div class="en">
  <p><span class="ptag" title="16.1 [over.load]/3">3</span> [Note: As specified in 11.3.5, function declarations that have equivalent parameter declarations declare the
  same function and therefore cannot be overloaded:
  </p>
  <ul>
  <li><span class="ptag" title="16.1 [over.load]/(3.1)">(3.1)</span> Parameter declarations that differ only in the use of equivalent typedef “types” are equivalent. A
    typedef is not a separate type, but only a synonym for another type (10.1.3). [Example:
<pre class="agh-prog-cpp">
typedef int Int;
void f(int i);
void f(Int i);              // OK: redeclaration of f(int)
void f(int i) { /* ... */ }
void f(Int i) { /* ... */ } // error: redefinition of f(int)
</pre>
    —end example ]
    Enumerations, on the other hand, are distinct types and can be used to distinguish overloaded function
    declarations. [Example:
<pre class="agh-prog-cpp">
enum E { a };
void f(int i) { /* ... */ }
void f(E i) { /* ... */ }
</pre>
    —end example ]
    </li>
  <li><span class="ptag" title="16.1 [over.load]/(3.2)">(3.2)</span> Parameter declarations that differ only in a pointer * versus an array [] are equivalent. That is, the
    array declaration is adjusted to become a pointer declaration (11.3.5). Only the second and subsequent
    array dimensions are significant in parameter types (11.3.4). [Example:
<pre class="agh-prog-cpp">
int f(char*);
int f(char[]);      // same as f(char*);
int f(char[7]);     // same as f(char*);
int f(char[9]);     // same as f(char*);
int g(char(*)[10]);
int g(char[5][10]); // same as g(char(*)[10]);
int g(char[7][10]); // same as g(char(*)[10]);
int g(char(*)[20]); // different from g(char(*)[10]);
</pre>
    —end example ]
    </li>
  <li><span class="ptag" title="16.1 [over.load]/(3.3)">(3.3)</span> Parameter declarations that differ only in that one is a function type and the other is a pointer to
    the same function type are equivalent. That is, the function type is adjusted to become a pointer to
    function type (11.3.5). [Example:
<pre class="agh-prog-cpp">
void h(int());
void h(int (*)());      // redeclaration of h(int())
void h(int x()) { }     // definition of h(int())
void h(int (*x)()) { }  // ill-formed: redefinition of h(int())
</pre>
    —end example ]
    </li>
  <li><span class="ptag" title="16.1 [over.load]/(3.4)">(3.4)</span> Parameter declarations that differ only in the presence or absence of const and/or volatile are
    equivalent. That is, the const and volatile type-specifiers for each parameter type are ignored when
    determining which function is being declared, defined, or called. [Example:
<pre class="agh-prog-cpp">
typedef const int cInt;
int f (int);
int f (const int);          // redeclaration of f(int)
int f (int) { /* ... */ }   // definition of f(int)
int f (cInt) { /* ... */ }  // error: redefinition of f(int)
</pre>
    —end example ]
    Only the const and volatile type-specifiers at the outermost level of the parameter type specification
    are ignored in this fashion; const and volatile type-specifiers buried within a parameter type
    specification are significant and can be used to distinguish overloaded function declarations. 123 In
    particular, for any type T , “pointer to T ”, “pointer to const T ”, and “pointer to volatile T ” are
    considered distinct parameter types, as are “reference to T ”, “reference to const T ”, and “reference to
    volatile T”.
    </li>
  <li><span class="ptag" title="16.1 [over.load]/(3.5)">(3.5)</span> Two parameter declarations that differ only in their default arguments are equivalent. [Example:
    Consider the following:
<pre class="agh-prog-cpp">
void f (int i, int j);
void f (int i, int j = 99); // OK: redeclaration of f(int, int)
void f (int i = 88, int j); // OK: redeclaration of f(int, int)
void f ();                  // OK: overloaded declaration of f
void prog () {
  f (1, 2);                 // OK: call f(int, int)
  f (1);                    // OK: call f(int, int)
  f ();                     // Error: f(int, int) or f()?
}
</pre>
    —end example ]
    </li>
  </ul>
  <p>—end note ]</p>
  <p><span class="ptag">footnote 123</span> When a parameter type includes a function type, such as in the case of a parameter type that is a pointer to function, the
  const and volatile type-specifiers at the outermost level of the parameter type specifications for the inner function type are
  also ignored.</p>
</div>

<h2 id="sec16.2">16.2 Declaration matching <span class="stag">[over.dcl]</span></h2>
<p><span class="ptag" id="sec16.2p1" title="16.2 [over.dcl]/1">1</span>
同名の関数宣言は、同じスコープにあり等価な仮引数宣言を持つ時、同一の関数を指す (16.1)。
派生クラスのメンバ関数は、基底クラスの同名のメンバ関数とは別のスコープにある。[例:
</p>
<pre class="agh-prog-cpp">
struct B {
  int f(int);
};
struct D : B {
  int f(const char*);
};
</pre>
<p>この時 <code class="agh-prog-cpp">D::f(const char*)</code> は <code class="agh-prog-cpp">B::f(int)</code> に多重定義を加えるのではなく、これを隠蔽する。</p>
<pre class="agh-prog-cpp">
void h(D* pd) {
  pd->f(1);     // error:
                // D::f(const char*) は B::f(int) を隠蔽する
  pd->B::f(1);  // OK
  pd->f("Ben"); // OK, D::f が呼び出される
}
</pre>
<p>- 例終わり ]</p>
<p class="translation-note">異なる型の変換関数は「名前」が違うという解釈なのだと思われる。</p>
<p class="translation-note">等価な仮引数宣言を持つが戻り値が異なる関数宣言は、関数型として異なるので多重定義になる (16/1)。
  しかし等価な仮引数宣言を持ち戻り値が異なる関数宣言は、多重定義できない (16.1/(2.1)。
  これにより等価な仮引数宣言を持つだけで、それが同一の関数であることが保証される。</p>
<p class="translation-note">原文には function member という語が出てくるがこれは member function の表記揺れであろう。</p>
<p class="translation-note">テンプレート引数について言及がないのは、この段落の関数宣言とは関数テンプレートは含まないからということだろうか。
  しかし、そうだとすると関数テンプレートの場合に同一の宣言かどうかを判定する記述が与えられず片手落ちである。</p>
<p><span class="ptag" id="sec16.2p2" title="16.2 [over.dcl]/2">2</span>
局所的に宣言された関数は、外側のスコープにある関数とは異なるスコープになる。[例:
</p>
<pre class="agh-prog-cpp">
void f(const char*);
void g() {
  extern void f(int);
  f("asdf");                  // error: f(int) は f(const char*) を隠蔽する。
                              // 従って、このスコープに f(const char*) は存在しない。
}
void caller () {
  extern void callee(int, int);
  {
    extern void callee(int);  // callee(int, int) を隠蔽する。
    callee(88, 99);           // error: このスコープには callee(int) しかない。
  }
}
</pre>
<p>- 例終わり ]</p>
<p><span class="ptag" id="sec16.2p3" title="16.2 [over.dcl]/3">3</span>
多重定義されたメンバ関数のそれぞれに対して異なるアクセス規則を割り当てることができる。[例:</p>
<pre class="agh-prog-cpp">
class buffer {
private:
  char* p;
  int size;
protected:
  buffer(int s, char* store) { size = s; p = store; }
public:
  buffer(int s) { p = new char[size = s]; }
};
</pre>
<p>- 例終わり ]</p>

<div class="en">
  <p><span class="ptag" title="16.2 [over.dcl]/1">1</span>
  Two function declarations of the same name refer to the same function if they are in the same scope and
  have equivalent parameter declarations (16.1). A function member of a derived class is not in the same scope
  as a function member of the same name in a base class. [Example:
  </p>
<pre class="agh-prog-cpp">
struct B {
  int f(int);
};
struct D : B {
  int f(const char*);
};
</pre>
  <p>Here D::f(const char*) hides B::f(int) rather than overloading it.</p>
<pre class="agh-prog-cpp">
void h(D* pd) {
  pd->f(1);     // error:
                // D::f(const char*) hides B::f(int)
  pd->B::f(1);  // OK
  pd->f("Ben"); // OK, calls D::f
}
</pre>
  <p>—end example ]</p>
  <p><span class="ptag" title="16.2 [over.dcl]/2">2</span>
  A locally declared function is not in the same scope as a function in a containing scope. [Example:
  </p>
<pre class="agh-prog-cpp">
void f(const char*);
void g() {
  extern void f(int);
  f("asdf");                  // error: f(int) hides f(const char*)
                              // so there is no f(const char*) in this scope
}
void caller () {
  extern void callee(int, int);
  {
    extern void callee(int);  // hides callee(int, int)
    callee(88, 99);           // error: only callee(int) in scope
  }
}
</pre>
  <p>—end example ]</p>
  <p><span class="ptag" title="16.2 [over.dcl]/3">3</span>
  Different versions of an overloaded member function can be given different access rules. [Example:</p>
<pre class="agh-prog-cpp">
class buffer {
private:
  char* p;
  int size;
protected:
  buffer(int s, char* store) { size = s; p = store; }
public:
  buffer(int s) { p = new char[size = s]; }
};
</pre>
  <p>—end example ]</p>
</div>

<h2 id="sec16.3">16.3 Overload resolution <span class="stag">[over.match]</span></h2>
<p><span class="ptag" id="sec16.3p1" title="16.3 [over.match]/1">1</span>
多重定義解決は、関数の呼び出しにおいて最適の関数を選択する仕組みである。
実引数の式のリストと、呼び出しの文脈における<dfn>候補関数</dfn> (candidate functions) の集合が考慮される。
選択の判断材料として、実引数の数、
実引数の仮引数型のリストへの合致度合い、
オブジェクトの暗黙オブジェクト仮引数への合致度合い、
その他の色々の候補関数の性質が用いられる。
[註: 多重定義解決で選択される関数は必ずしもその文脈で適切であるとは限らない。
関数のアクセス可能性などの他の制限によって、その呼び出しが不適格になることがある。 - 註終わり ]
</p>
<p><span class="ptag" id="sec16.3p2" title="16.3 [over.match]/2">2</span>
  7つの異なる文脈で多重定義解決が実行される:
</p>
<ul>
<li><span class="ptag" id="sec16.3p2.1" title="16.3 [over.match]/(2.1)">(2.1)</span> 関数呼び出し構文で名前の指定された関数の呼び出し (16.3.1.1.1);</li>
<li><span class="ptag" id="sec16.3p2.2" title="16.3 [over.match]/(2.2)">(2.2)</span> 関数呼び出し構文で名前の指定されたクラスオブジェクトに対する、
  関数呼び出し演算子、関数ポインタへの変換関数、関数ポインタの参照への変換関数、関数の参照への変換関数の呼び出し (16.3.1.1.2);</li>
<li><span class="ptag" id="sec16.3p2.3" title="16.3 [over.match]/(2.3)">(2.3)</span> 式中で参照された演算子の呼び出し (16.3.1.2);</li>
<li><span class="ptag" id="sec16.3p2.4" title="16.3 [over.match]/(2.4)">(2.4)</span> クラスオブジェクトの既定初期化または直接初期化 (11.6) に際してのコンストラクタの呼び出し (16.3.1.3);</li>
<li><span class="ptag" id="sec16.3p2.5" title="16.3 [over.match]/(2.5)">(2.5)</span> クラスオブジェクトのコピー初期化 (11.6) に際してのユーザ定義の変換の呼び出し (16.3.1.4);</li>
<li><span class="ptag" id="sec16.3p2.6" title="16.3 [over.match]/(2.6)">(2.6)</span> クラス型の式による非クラス型のオブジェクトの初期化に際しての変換の呼び出し (16.3.1.5);</li>
<li><span class="ptag" id="sec16.3p2.7" title="16.3 [over.match]/(2.7)">(2.7)</span> 参照 (11.6.3) の束縛対象の glvalue またはクラス prvalue を得るための変換関数の呼び出し (16.3.1.6).</li>
</ul>
<p>それぞれの文脈ごとに候補関数の集合と実引数のリストの決定方法が与えられる。
ひとたび候補関数と実引数のリストが与えられれば、最適な関数の選択方法は何れの文脈でも共通である:
</p>
<ul>
<li><span class="ptag" id="sec16.3p2.8" title="16.3 [over.match]/(2.8)">(2.8)</span>
  初めに、適切な数の仮引数を持つかどうかなどの条件を満たす候補関数の部分集合として、
  呼び出し可能関数を選別する (16.3.2)。</li>
<li><span class="ptag" id="sec16.3p2.9" title="16.3 [over.match]/(2.9)">(2.9)</span>
  次に、実引数をそれぞれ対応する仮引数に合致させるのに使う暗黙変換列 (16.3.3.1) に基づいて、
  最適な呼び出し可能関数を選択する。</li>
</ul>
<p><span class="ptag" id="sec16.3p3" title="16.3 [over.match]/3">3</span>
最適な呼び出し可能関数が一意に存在するときに多重定義解決は成功とし、その関数が結果となる。
それ以外の場合は、多重定義解決は失敗であり、その関数呼び出しは不適格である。
多重定義解決が成功したものの最適な呼び出し可能関数がその文脈でアクセス可能 (Clause 14) でないとき、プログラムは不適格である。
</p>

<p class="translation-note">原文 16.3/(2.8) the proper number of arguments は the proper number of parameters の誤りではないか。</p>
<div class="en">
  <p><span class="ptag" title="16.3 [over.match]/1">1</span>
  Overload resolution is a mechanism for selecting the best function to call given a list of expressions that are
  to be the arguments of the call and a set of candidate functions that can be called based on the context of
  the call. The selection criteria for the best function are the number of arguments, how well the arguments
  match the parameter-type-list of the candidate function, how well (for non-static member functions) the
  object matches the implicit object parameter, and certain other properties of the candidate function. [Note:
  The function selected by overload resolution is not guaranteed to be appropriate for the context. Other
  restrictions, such as the accessibility of the function, can make its use in the calling context ill-formed. —end
  note ]
  </p>
  <p><span class="ptag" title="16.3 [over.match]/2">2</span>
  Overload resolution selects the function to call in seven distinct contexts within the language:
  </p>
  <ul>
  <li><span class="ptag" title="16.3 [over.match]/(2.1)">(2.1)</span> invocation of a function named in the function call syntax (16.3.1.1.1);</li>
  <li><span class="ptag" title="16.3 [over.match]/(2.2)">(2.2)</span> invocation of a function call operator, a pointer-to-function conversion function,
    a reference-to-pointer-to-function conversion function, or a reference-to-function conversion function on a class object named
    in the function call syntax (16.3.1.1.2);</li>
  <li><span class="ptag" title="16.3 [over.match]/(2.3)">(2.3)</span> invocation of the operator referenced in an expression (16.3.1.2);</li>
  <li><span class="ptag" title="16.3 [over.match]/(2.4)">(2.4)</span> invocation of a constructor for default- or direct-initialization (11.6) of a class object (16.3.1.3);</li>
  <li><span class="ptag" title="16.3 [over.match]/(2.5)">(2.5)</span> invocation of a user-defined conversion for copy-initialization (11.6) of a class object (16.3.1.4);</li>
  <li><span class="ptag" title="16.3 [over.match]/(2.6)">(2.6)</span> invocation of a conversion function for initialization of an object of a non-class type from an expression
    of class type (16.3.1.5); and</li>
  <li><span class="ptag" title="16.3 [over.match]/(2.7)">(2.7)</span> invocation of a conversion function for conversion to a glvalue or class prvalue to which a reference (11.6.3)
    will be directly bound (16.3.1.6).</li>
  </ul>
  <p>Each of these contexts defines the set of candidate functions and the list of arguments in its own unique way.
  But, once the candidate functions and argument lists have been identified, the selection of the best function
  is the same in all cases:
  </p>
  <ul>
  <li><span class="ptag" title="16.3 [over.match]/(2.8)">(2.8)</span> First, a subset of the candidate functions (those that have the proper number of arguments and meet
    certain other conditions) is selected to form a set of viable functions (16.3.2).</li>
  <li><span class="ptag" title="16.3 [over.match]/(2.9)">(2.9)</span> Then the best viable function is selected based on the implicit conversion sequences (16.3.3.1) needed
    to match each argument to the corresponding parameter of each viable function.</li>
  </ul>
  <p><span class="ptag" title="16.3 [over.match]/3">3</span>
  If a best viable function exists and is unique, overload resolution succeeds and produces it as the result.
  Otherwise overload resolution fails and the invocation is ill-formed. When overload resolution succeeds,
  and the best viable function is not accessible (Clause 14) in the context in which it is used, the program is
  ill-formed.
  </p>
</div>

<h3 id="sec16.3.1">16.3.1 Candidate functions and argument lists <span class="stag">[over.match.funcs]</span></h3>
<p><span class="ptag" id="sec16.3.1p1" title="16.3.1 [over.match.funcs]/1">1</span>
この節 16.3.1 では多重定義の行われる7つの文脈のそれぞれについて、
多重定義解決に使われる候補関数の集合と実引数リストを記述する。
ここで定義されるソースコードの変換や構造は多重定義解決を定義するために導入するもので、
処理系は必ずしもこれらの変換や構造を実際に使用しなくても良い。
</p>
<p><span class="ptag" id="sec16.3.1p2" title="16.3.1 [over.match.funcs]/2">2</span>
候補関数の集合は、同じ実引数リストに対してメンバ関数と非メンバ関数の両方を含むこともある。
この異質の候補関数を含む集合について実引数と仮引数のリストを比較するために、
メンバ関数は<dfn>暗黙オブジェクト仮引数</dfn> (implicit object parameter) という追加の仮引数を持つものとみなし、
この仮引数はメンバ関数を呼び出す対象のオブジェクトを表す。
多重定義解決において、静的・非静的メンバ関数は共に暗黙オブジェクト仮引数を持つとする。
一方でコンストラクタは暗黙オブジェクト仮引数を持たない。
</p>
<p class="translation-note">本当に同時にメンバ関数と非メンバ関数を両方含むことがあるのか?
だとすると、非メンバ関数も暗黙引数を入れなければ比較できないのでは? 要確認■
(1) 16.3.1.1.1/3 によると<i>関数呼び出しでは</i>メンバ関数と非メンバ関数が両方同時に含まれることはない。
</p>
<p><span class="ptag" id="sec16.3.1p3" title="16.3.1 [over.match.funcs]/3">3</span>
同様に、文脈に応じて、<dfn>暗黙オブジェクト実引数</dfn> (implied object argument) を含む実引数リストが構築される。
暗黙オブジェクト実引数はメンバ関数を呼び出す対象のオブジェクトを表す。
実引数と仮引数はそれぞれの属するリスト中の位置で指定されるので、
ここでは暗黙オブジェクト仮引数・実引数があるときは、
それはリスト中の一番初めの実引数・仮引数であるとして取り扱うことにする。
</p>
<p><span class="ptag" id="sec16.3.1p4" title="16.3.1 [over.match.funcs]/4">4</span>
非静的メンバ関数の暗黙オブジェクト仮引数の型は、
</p>
<ul>
<li><span class="ptag" id="sec16.3.1p4.1" title="16.3.1 [over.match.funcs]/(4.1)">(4.1)</span>
  ref 修飾子のないまたは <code class="agh-prog-cpp">&amp;</code> ref 修飾子のついた関数については
  <i>cv</i> <code class="agh-prog-cpp">X</code> の左辺値参照であり、</li>
<li><span class="ptag" id="sec16.3.1p4.2" title="16.3.1 [over.match.funcs]/(4.2)">(4.2)</span>
  <code class="agh-prog-cpp">&amp;&amp;</code> ref 修飾子のついた関数については
  <i>cv</i> <code class="agh-prog-cpp">X</code> の右辺値参照である。</li>
</ul>
<p>但し、<code class="agh-prog-cpp">X</code> は関数がメンバとして属するクラスであり、
<i>cv</i> はそのメンバ関数の宣言の cv 修飾である。[例:
クラス <code class="agh-prog-cpp">X</code> の <code class="agh-prog-cpp">const</code> メンバ関数について、
追加の仮引数は <code class="agh-prog-cpp">const X</code> の参照を持つと考える。- 例終わり ]
変換関数は、
暗黙オブジェクト仮引数の型を決めるために、
暗黙オブジェクト実引数のクラスのメンバであると考える。
using 宣言を用いて派生クラスに導入された変換関数以外の関数は、
暗黙オブジェクト仮引数の型を決めるために、
派生クラスのメンバであると考える。
静的メンバ関数については、
(もし採用された場合、暗黙オブジェクト実引数は使われないので)、
暗黙オブジェクト仮引数はいかなるオブジェクトにも一致すると考える。
[註: 静的メンバ関数の暗黙オブジェクト仮引数には実際の型は決めず、
また、その仮引数に対する変換列が決定されることもない (16.3.3) - 註終わり ]
</p>
<p><span class="ptag" id="sec16.3.1p5" title="16.3.1 [over.match.funcs]/5">5</span>
多重定義解決において、暗黙オブジェクト実引数は他の実引数と同様に取り扱う。
一方で暗黙オブジェクト仮引数については、
実引数の型を一致させるためにユーザ定義変換を使えない規則 <span class="tcomment">16.3.3.1/7</span> のために、
自身が暗黙オブジェクト仮引数であることを覚えておく必要がある。
ref 修飾子のない非静的メンバ関数については以下の追加の規則が適用される:
</p>
<ul>
<li><span class="ptag" id="sec16.3.1p5.1" title="16.3.1 [over.match.funcs]/(5.1)">(5.1)</span>
  暗黙オブジェクト仮引数が const 修飾されていなくても、
  その点を除いてその暗黙オブジェクト仮引数の型に変換可能な rvalue の実引数は、
  その暗黙オブジェクト仮引数に束縛されうる。
  [註: その実引数が rvalue であることは、暗黙変換列のランク (16.3.3.2) に影響しない。- 註終わり ]</li>
</ul>
<p><span class="ptag" id="sec16.3.1p6" title="16.3.1 [over.match.funcs]/6">6</span>
リスト初期化以外ではユーザ定義変換は高々1回までなので、
最適なユーザ定義変換を選ぶときに特別な規則が適用される(16.3.3, 16.3.3.1)。[例:
</p>
<pre class="agh-prog-cpp">
class T {
public:
  T();
};
class C : T {
public:
  C(int);
};
T a = 1;      // 不適格: T(C(1)) は考慮されない
</pre>
<p>- 例終わり ]</p>
<p><span class="ptag" id="sec16.3.1p7" title="16.3.1 [over.match.funcs]/7">7</span>
候補が関数テンプレートの場合、
テンプレート実引数推論 (17.8.3, 17.8.2) を経て、
候補の関数テンプレート特殊化が生成され、
以降は通常の候補関数と同様に取り扱われる<sup>124</sup>。
与えられた関数名は、1つ以上の関数テンプレートと
多重定義された非テンプレート関数の集合を同時に指すこともある。
その場合は、それぞれの関数テンプレートから生成された候補関数は、
非テンプレート候補関数の集合に合流させて取り扱われる。
</p>
<p><span class="ptag" id="sec16.3.1p8" title="16.3.1 [over.match.funcs]/8">8</span>
どの文脈でも、既定化されたムーブコンストラクタ (15.8) と削除された代入演算子は候補関数の集合に含まれない。
</p>
<p><span class="ptag" id="footnote124">footnote 124</span>
実引数推論の過程で関数テンプレート特殊化の仮引数の型は完全に定まる。
つまり、関数テンプレート特殊化の仮引数にはテンプレート仮引数は残らない。
従って、特に指定がない限りは、関数テンプレート特殊化と非テンプレート関数 (11.3.5) は、
多重定義解決の残りの部分で同等に取り扱われる。
</p>

<div class="en">
  <p><span class="ptag" title="16.3.1 [over.match.funcs]/1">1</span>
  The subclauses of 16.3.1 describe the set of candidate functions and the argument list submitted to overload
  resolution in each of the seven contexts in which overload resolution is used. The source transformations
  and constructions defined in these subclauses are only for the purpose of describing the overload resolution
  process. An implementation is not required to use such transformations and constructions.
  </p>
  <p><span class="ptag" title="16.3.1 [over.match.funcs]/2">2</span>
  The set of candidate functions can contain both member and non-member functions to be resolved against
  the same argument list. So that argument and parameter lists are comparable within this heterogeneous set,
  a member function is considered to have an extra parameter, called the implicit object parameter, which
  represents the object for which the member function has been called. For the purposes of overload resolution,
  both static and non-static member functions have an implicit object parameter, but constructors do not.
  </p>
  <p><span class="ptag" title="16.3.1 [over.match.funcs]/3">3</span>
  Similarly, when appropriate, the context can construct an argument list that contains an implied object
  argument to denote the object to be operated on. Since arguments and parameters are associated by position
  within their respective lists, the convention is that the implicit object parameter, if present, is always the
  first parameter and the implied object argument, if present, is always the first argument.
  </p>
  <p><span class="ptag" title="16.3.1 [over.match.funcs]/4">4</span>
  For non-static member functions, the type of the implicit object parameter is
  </p>
  <ul>
  <li><span class="ptag" title="16.3.1 [over.match.funcs]/(4.1)">(4.1)</span>
    “lvalue reference to cv X” for functions declared without a ref-qualifier or with the &amp; ref-qualifier</li>
  <li><span class="ptag" title="16.3.1 [over.match.funcs]/(4.2)">(4.2)</span>
    “rvalue reference to cv X” for functions declared with the &amp;&amp; ref-qualifier</li>
  </ul>
  <p>where X is the class of which the function is a member and cv is the cv-qualification on the member function
  declaration. [Example: For a const member function of class X , the extra parameter is assumed to have
  type “reference to const X ”. —end example ] For conversion functions, the function is considered to be
  a member of the class of the implied object argument for the purpose of defining the type of the implicit
  object parameter. For non-conversion functions introduced by a using-declaration into a derived class, the
  function is considered to be a member of the derived class for the purpose of defining the type of the implicit
  object parameter. For static member functions, the implicit object parameter is considered to match any
  object (since if the function is selected, the object is discarded). [Note: No actual type is established for
  the implicit object parameter of a static member function, and no attempt will be made to determine a
  conversion sequence for that parameter (16.3.3). —end note ]
  </p>
  <p><span class="ptag" title="16.3.1 [over.match.funcs]/5">5</span>
  During overload resolution, the implied object argument is indistinguishable from other arguments. The
  implicit object parameter, however, retains its identity since no user-defined conversions can be applied to
  achieve a type match with it. For non-static member functions declared without a ref-qualifier, an additional
  rule applies:
  </p>
  <ul>
  <li><span class="ptag" title="16.3.1 [over.match.funcs]/(5.1)">(5.1)</span>
    even if the implicit object parameter is not const-qualified, an rvalue can be bound to the parameter as
    long as in all other respects the argument can be converted to the type of the implicit object parameter.
    [Note: The fact that such an argument is an rvalue does not affect the ranking of implicit conversion
    sequences (16.3.3.2). —end note ]
  </li>
  </ul>
  <p><span class="ptag" title="16.3.1 [over.match.funcs]/6">6</span>
  Because other than in list-initialization only one user-defined conversion is allowed in an implicit conversion
  sequence, special rules apply when selecting the best user-defined conversion (16.3.3, 16.3.3.1). [Example:
  </p>
<pre class="agh-prog-cpp">
class T {
public:
  T();
};
class C : T {
public:
  C(int);
};
T a = 1;      // ill-formed: T(C(1)) not tried
</pre>
  <p>—end example ]</p>
  <p><span class="ptag" title="16.3.1 [over.match.funcs]/7">7</span>
  In each case where a candidate is a function template, candidate function template specializations are
  generated using template argument deduction (17.8.3, 17.8.2). Those candidates are then handled as
  candidate functions in the usual way. 124 A given name can refer to one or more function templates and also
  to a set of overloaded non-template functions. In such a case, the candidate functions generated from each
  function template are combined with the set of non-template candidate functions.
  </p>
  <p><span class="ptag" title="16.3.1 [over.match.funcs]/8">8</span>
  A defaulted move constructor or assignment operator (15.8) that is defined as deleted is excluded from the
  set of candidate functions in all contexts.
  </p>
  <p><span class="ptag">footnote 124</span>
  The process of argument deduction fully determines the parameter types of the function template specializations, i.e.,
  the parameters of function template specializations contain no template parameter types. Therefore, except where specified
  otherwise, function template specializations and non-template functions (11.3.5) are treated equivalently for the remainder of
  overload resolution.
  </p>
</div>

<h4 id="sec16.3.3.1">16.3.1.1 Function call syntax <span class="stag">[over.match.call]</span></h4>
<p><span class="ptag" id="sec16.3.1.1p1" title="16.3.1.1 [over.match.call]/1">1</span>
関数呼び出し (8.2.2)</p>
<div class="syntax">
  <span class="syntax">postfix-expression</span> <code>(</code> <span class="syntax">expression-list</span><sub class="opt">opt</sub> <code>)</code>
</div>
<p>において、<span class="syntax">postfix-expression</span> が多重定義された関数・関数テンプレートの集合を表すとき、
多重定義解決は 16.3.1.1.1 で指定される方法で適用される。
<span class="syntax">postfix-expression</span> がクラス型のオブジェクトを表すとき、
多重定義解決は 16.3.1.1.2 で指定される方法で適用される。
</p>
<p><span class="ptag" id="sec16.3.1.1p2" title="16.3.1.1 [over.match.call]/2">2</span>
<span class="syntax">postfix-expression</span> が多重定義された関数・関数テンプレートの集合のアドレスを表すとき、
その集合に対して上記の多重定義解決を適用する。
多重定義解決で選ばれた関数が非静的メンバ関数のとき、プログラムは不適格である。
[註: 他の文脈における多重定義された集合のアドレスの解決は 16.4 で述べる。 - 註終わり ]
</p>

<div class="en">
  <p><span class="ptag" title="16.3.1.1 [over.match.call]/1">1</span>
  In a function call (8.2.2)</p>
  <div class="syntax">
    <span class="syntax">postfix-expression</span> <code>(</code> <span class="syntax">expression-list</span><sub class="opt">opt</sub> <code>)</code>
  </div>
  <p>if the postfix-expression denotes a set of overloaded functions and/or function templates, overload resolution is
  applied as specified in 16.3.1.1.1. If the postfix-expression denotes an object of class type, overload resolution
  is applied as specified in 16.3.1.1.2.
  </p>
  <p><span class="ptag" title="16.3.1.1 [over.match.call]/2">2</span>
  If the postfix-expression denotes the address of a set of overloaded functions and/or function templates,
  overload resolution is applied using that set as described above. If the function selected by overload resolution
  is a non-static member function, the program is ill-formed. [Note: The resolution of the address of an
  overload set in other contexts is described in 16.4. —end note ]
  </p>
</div>

<h5 id="sec16.3.1.1.1">16.3.1.1.1 Call to named function <span class="stag">[over.call.func]</span></h5>
<p><span class="ptag" id="sec16.3.1.1.1p1" title="16.3.1.1.1 [over.call.func]/1">1</span>
16.3.1.1.1 で取り扱う関数呼び出しは、
<span class="syntax">postfix-expression</span> が呼び出す関数候補の名前を含むものである。
そのような <span class="syntax">postfix-expression</span> は、
以下の形式、またはそれを任意の深さの丸括弧で括ったものになっている:
</p>
<div class="syntax">
  <span class="syntax">postfix-expression</span>:
  <div class="syntax">
    <span class="syntax">postfix-expression</span> <code>.</code> <span class="syntax">id-expression</span>
  </div>
  <div class="syntax">
    <span class="syntax">postfix-expression</span> <code>-></code> <span class="syntax">id-expression</span>
  </div>
  <div class="syntax">
    <span class="syntax">primary-expression</span>
  </div>
</div>
<p>これに基づき2つの文法的分類、即ち<dfn>修飾付き関数呼び出し</dfn> (qualified function calls)
と<dfn>修飾なし関数呼び出し</dfn> (unqualified function calls) が定められる。
</p>
<p><span class="ptag" id="sec16.3.1.1.1p2" title="16.3.1.1.1 [over.call.func]/2">2</span>
修飾付き関数呼び出しでは、
<code class="agh-prog-cpp">-></code> または <code class="agh-prog-cpp">.</code> 演算子に続く
<span class="syntax">id-expression</span> が解決する名前になる。
構文 <code class="agh-prog-cpp">A->B</code> は一般に <code class="agh-prog-cpp">(*A).B</code> に等価なため、
以降 Clause 16 では、一般性を失うことなく、
全てのメンバ関数呼び出しはオブジェクトと <code class="agh-prog-cpp">.</code> 演算子を用いた形式に正規化されているものとして扱う。
加えて、Clause 16 では <code class="agh-prog-cpp">.</code> 演算子の左辺 <span class="syntax">postfix-expression</span> の型は
クラス型 <code class="agh-prog-cpp">T</code> を以て "<i>cv</i> <code class="agh-prog-cpp">T</code>" とする<sup>125</sup>。
この仮定の下、関数呼び出しの <span class="syntax">id-expression</span> は、
<code class="agh-prog-cpp">T</code> のメンバ関数として
クラス中の名前探索 (13.2) の規則に基いて探索される。
この探索で見つかった関数宣言が候補関数の集合を為す。
実引数リストは、
正規化した呼び出しにおける <code class="agh-prog-cpp">.</code> 演算子の左辺を暗黙オブジェクト実引数として、
関数呼び出しの <span class="syntax">expression-list</span> を拡張したものになる (16.3.1)。
</p>
<p><span class="ptag" id="sec16.3.1.1.1p3" title="16.3.1.1.1 [over.call.func]/3">3</span>
修飾なしの関数呼び出しでは名前は <code class="agh-prog-cpp">-></code>
または <code class="agh-prog-cpp">.</code> 演算子によって修飾されず、
より一般の形 <span class="syntax">primary-expression</span> をしている。
関数呼び出しの文脈では、関数呼び出しの通常の名前探索の規則 (6.4) によって名前が探索される。
名前探索で見つかった関数宣言が候補関数となる。
名前探索の規則により、候補関数の集合は (1) 全て非メンバ関数であるか
(2) 全て或るクラス <code class="agh-prog-cpp">T</code> のメンバ関数である。
(1) の場合、実引数リストは関数呼び出しの <span class="syntax">expression-list</span> と同じである。
(2) の場合、修飾付き関数呼び出しのときと同様に、
実引数リストは暗黙オブジェクト実引数によって
関数呼び出しの <span class="syntax">expression-list</span> を拡張したものになる。
キーワード <code class="agh-prog-cpp">this</code> (12.2.2.1) がスコープ内にあって
クラス <code class="agh-prog-cpp">T</code> またはその派生クラスを指すとき、
暗黙オブジェクト実引数は <code class="agh-prog-cpp">(*this)</code> である。
キーワード <code class="agh-prog-cpp">this</code> がスコープ内にないか他のクラスを指すとき、
型 <code class="agh-prog-cpp">T</code> の仮想的に導入されたオブジェクトが暗黙オブジェクト実引数になる<sup>126</sup>。
実引数リストが仮想的に導入されたオブジェクトで拡張された場合、
多重定義解決の結果が <code class="agh-prog-cpp">T</code> の非静的メンバ関数ならば、その呼び出しは不適格である。
</p>
<p class="translation-note">
原文に contrived object という単語が出てくるが、これは規格の中でこの箇所でしか出てこない。
</p>
<p><span class="ptag" id="footnote125">footnote 125</span>
オブジェクトが glvalue であってもクラス型の prvalue であっても、
オブジェクトの型の cv 修飾子は多重定義解決で意味を持つことに注意する。
</p>
<p><span class="ptag" id="footnote126">footnote 126</span>
多重定義解決の手続き上、
メンバ関数の暗黙オブジェクト仮引数に対応して
暗黙オブジェクト実引数を仮想的に導入する必要がある。
<span class="tcomment">このとき静的関数しか許されないので</span>
この暗黙オブジェクト実引数は最終的な関数呼び出しには用いられない。
メンバ関数は全て同じ暗黙オブジェクト仮引数を持つので、
この仮想的に導入されるオブジェクトは各関数の選択・棄却には影響を与えない。
</p>
<p class="translation-note">
「メンバ関数は全て同じ暗黙オブジェクト仮引数を持つので (原文: Since the member functions all have the
same implicit object parameter)」→ 16.3.1/4 に従い、
関数の ref-qualifier, cv-qualifier によって仮引数は異なるのではないか。
これは「静的メンバ関数は～」の誤りである気がする。
</p>

<div class="en">
  <p><span class="ptag" title="16.3.1.1.1 [over.call.func]/1">1</span>
  Of interest in 16.3.1.1.1 are only those function calls in which the postfix-expression ultimately contains a
  name that denotes one or more functions that might be called. Such a postfix-expression, perhaps nested
  arbitrarily deep in parentheses, has one of the following forms:
  </p>
  <div class="syntax">
    <span class="syntax">postfix-expression</span>:
    <div class="syntax">
      <span class="syntax">postfix-expression</span> <code>.</code> <span class="syntax">id-expression</span>
    </div>
    <div class="syntax">
      <span class="syntax">postfix-expression</span> <code>-></code> <span class="syntax">id-expression</span>
    </div>
    <div class="syntax">
      <span class="syntax">primary-expression</span>
    </div>
  </div>
  <p>These represent two syntactic subcategories of function calls: qualified function calls and unqualified function
  calls.
  </p>
  <p><span class="ptag" title="16.3.1.1.1 [over.call.func]/2">2</span>
  In qualified function calls, the name to be resolved is an id-expression and is preceded by an -> or . operator.
  Since the construct A->B is generally equivalent to (*A).B , the rest of Clause 16 assumes, without loss of
  generality, that all member function calls have been normalized to the form that uses an object and the
  . operator. Furthermore, Clause 16 assumes that the postfix-expression that is the left operand of the .
  operator has type “cv T ” where T denotes a class 125 . Under this assumption, the id-expression in the call
  is looked up as a member function of T following the rules for looking up names in classes (13.2). The
  function declarations found by that lookup constitute the set of candidate functions. The argument list is the
  expression-list in the call augmented by the addition of the left operand of the . operator in the normalized
  member function call as the implied object argument (16.3.1).
  </p>
  <p><span class="ptag" title="16.3.1.1.1 [over.call.func]/3">3</span>
  In unqualified function calls, the name is not qualified by an -> or . operator and has the more general form
  of a primary-expression. The name is looked up in the context of the function call following the normal
  rules for name lookup in function calls (6.4). The function declarations found by that lookup constitute the
  set of candidate functions. Because of the rules for name lookup, the set of candidate functions consists
  (1) entirely of non-member functions or (2) entirely of member functions of some class T . In case (1), the
  argument list is the same as the expression-list in the call. In case (2), the argument list is the expression-list
  in the call augmented by the addition of an implied object argument as in a qualified function call. If the
  keyword this (12.2.2.1) is in scope and refers to class T , or a derived class of T , then the implied object
  argument is (*this) . If the keyword this is not in scope or refers to another class, then a contrived object
  of type T becomes the implied object argument 126 . If the argument list is augmented by a contrived object
  and overload resolution selects one of the non-static member functions of T, the call is ill-formed.
  </p>
  <p><span class="ptag">footnote 125</span>
  Note that cv-qualifiers on the type of objects are significant in overload resolution for both glvalue and class prvalue objects.
  </p>
  <p><span class="ptag">footnote 126</span>
  An implied object argument must be contrived to correspond to the implicit object parameter attributed to member
  functions during overload resolution. It is not used in the call to the selected function. Since the member functions all have the
  same implicit object parameter, the contrived object will not be the cause to select or reject a function.
  </p>
</div>

<h5 id="sec16.3.1.1.2">16.3.1.1.2 Call to object of class type <span class="stag">[over.call.object]</span></h5>
<p><span class="ptag" id="sec16.3.1.1.2p1" title="16.3.1.1.2 [over.call.object]/1">1</span>
関数呼び出し構文の <span class="syntax">primary-expression</span> <code>E</code> が
型 "<code class="agh-prog-cpp"><i>cv</i> T</code>" のクラスオブジェクトに評価されるとき、
候補関数の集合は少なくとも <code class="agh-prog-cpp">T</code> の関数呼び出し演算子を含む。
<code class="agh-prog-cpp">T</code> の関数呼び出し演算子は、
<code class="agh-prog-cpp">(E).operator()</code> における名前 <code class="agh-prog-cpp">operator()</code>
の通常の探索によって得られる。
</p>
<p><span class="ptag" id="sec16.3.1.1.2p2" title="16.3.1.1.2 [over.call.object]/2">2</span>
更に、以下の形式を持つ <code class="agh-prog-cpp">T</code> の非明示的な変換関数について考える。
</p>
<div class="syntax">
  <code>operator</code> <span class="syntax">conversion-type-id</span> <code>()</code> <span class="syntax">cv-qualifier</span>
  <span class="syntax">ref-qualifier</span><sub class="opt">opt</sub>
  <span class="syntax">noexcept-specifier</span><sub class="opt">opt</sub>
  <span class="syntax">attribute-specifier-seq</span><sub class="opt">opt</sub> <code>;</code>
</div>
<p>
<span class="syntax">cv-qualifier</span> が <i>cv</i> と同じかより強い cv 修飾であり、
<span class="syntax">conversion-type-id</span> が
型 "(<code class="agh-prog-cpp">P</code><sub>1</sub> , ..., <code class="agh-prog-cpp">P</code><sub><i>n</i></sub>) を受け取り <code  class="agh-prog-cpp">R</code> を返す関数ポインタ"、
または型 "(<code class="agh-prog-cpp">P</code><sub>1</sub> , ..., <code class="agh-prog-cpp">P</code><sub><i>n</i></sub>) を受け取り <code  class="agh-prog-cpp">R</code> を返す関数ポインタの参照"
または型 "(<code class="agh-prog-cpp">P</code><sub>1</sub> , ..., <code class="agh-prog-cpp">P</code><sub><i>n</i></sub>) を受け取り <code  class="agh-prog-cpp">R</code> を返す関数の参照" ならば、
以下の形式の<dfn>代理呼び出し関数</dfn> (surrogate call function) も候補関数に加えられる。
</p>
<div class="syntax">
  <code>R</code> <span class="syntax">call-function</span>
  <code>(</code> <span class="syntax">conversion-type-id</span> <code>F,</code>
    <code>P<sub>1</sub></code> <code>a<sub>1</sub> ,</code>
    ...<code>,</code>
    <code>P</code><sub><i>n</i></sub> <code>a</code><sub><i>n</i></sub><code>)</code>
  <code>{ return F (a<sub>1</sub> ,</code> ...<code>, a</code><sub><i>n</i></sub><code>); }</code>
</div>
<p>但し <span class="syntax">call-function</span> は他と区別できる一意な名前とする。
<code class="agh-prog-cpp">T</code> の基底クラスで宣言された非明示的な変換関数のそれぞれについても、
その変換関数が <code class="agh-prog-cpp">T</code> において他の intervening 宣言によって隠蔽されない限りにおいて、
同様にして代理呼び出し関数が候補関数の集合に追加される<sup>127</sup>。
</p>
<p class="translation-note">代理呼び出し関数は完全転送でなくて良いのか?
<a href="https://wandbox.org/permlink/j2hEGP6Vj3S8TGBh">やはり駄目な気がする</a> 
</p>
<p><span class="ptag" id="sec16.3.1.1.2p3" title="16.3.1.1.2 [over.call.object]/3">3</span>
多重定義解決によってこの様な代理呼び出し関数が選ばれたとき、
対応する変換関数を呼び出して <code>E</code> を適切な関数ポインタまたは参照に変換し、
それからその関数が関数呼び出し構文の実引数によって呼び出される。
もし (曖昧であるなどの理由で) 変換関数が呼び出せないとき、プログラムは不適格である。
</p>
<p class="translation-note">ところで「呼び出しは不適格である」と「プログラムは不適格である」に区別はあるのだろうか。</p>
<p><span class="ptag" id="sec16.3.1.1.2p4" title="16.3.1.1.2 [over.call.object]/4">4</span>
多重定義解決に渡される実引数リストは、
暗黙オブジェクト実引数 <code class="agh-prog-cpp">(E)</code> とそれに続く関数呼び出し構文に与えられた実引数の式からなる。
[註: 呼び出しを関数呼出し演算子と比較するとき、
暗黙オブジェクト実引数は関数呼び出し演算子の暗黙オブジェクト仮引数と比較される。
呼び出しを代理呼び出し関数と比較するとき、
暗黙オブジェクト実引数は代理呼び出し関数の第1仮引数と比較される。
代理呼び出し関数の元になった変換関数は、
暗黙オブジェクト実引数を第1仮引数が要求する関数ポインタまたは参照に変換するために、
第1仮引数の変換列の中で使われる。- 註終わり ] [例:
</p>
<pre class="agh-prog-cpp">
int f1(int);
int f2(float);
typedef int (*fp1)(int);
typedef int (*fp2)(float);
struct A {
  operator fp1() { return f1; }
  operator fp2() { return f2; }
} a;
int i = a(1);     // 変換関数から返されるポインタを通して f1 が呼び出される
</pre>
<p>—end example ]</p>
<p><span class="ptag" id="footnote127">footnote 127</span>
この手順により、同一の宣言であるまたは戻り値の型だけが異なるために、
互いに多重定義解決において区別できない複数の候補関数が生成されることがある。
多重定義解決において、このような区別できない候補関数よりも良い他の候補が見つからない場合は、呼び出しは曖昧になる。
</p>

<div class="en">
  <p><span class="ptag" title="16.3.1.1.2 [over.call.object]/1">1</span>
  If the primary-expression E in the function call syntax evaluates to a class object of type “cv T ”, then the set
  of candidate functions includes at least the function call operators of T . The function call operators of T are
  obtained by ordinary lookup of the name operator() in the context of (E).operator().
  </p>
  <p><span class="ptag" title="16.3.1.1.2 [over.call.object]/2">2</span>
  In addition, for each non-explicit conversion function declared in T of the form
  </p>
  <div class="syntax">
    <code>operator</code> <span class="syntax">conversion-type-id</span> <code>()</code> <span class="syntax">cv-qualifier</span>
    <span class="syntax">ref-qualifier</span><sub class="opt">opt</sub>
    <span class="syntax">noexcept-specifier</span><sub class="opt">opt</sub>
    <span class="syntax">attribute-specifier-seq</span><sub class="opt">opt</sub> <code>;</code>
  </div>
  <p>where cv-qualifier is the same cv-qualification as, or a greater cv-qualification than, cv, and where conversion-
  type-id denotes the type “pointer to function of ( P 1 ,...,P n ) returning R ”, or the type “reference to pointer
  to function of ( P 1 ,...,P n ) returning R ”, or the type “reference to function of ( P 1 ,...,P n ) returning R ”, a
  surrogate call function with the unique name call-function and having the form
  </p>
  <div class="syntax">
    <code>R</code> <span class="syntax">call-function</span>
    <code>(</code> <span class="syntax">conversion-type-id</span> <code>F,</code>
      <code>P<sub>1</sub></code> <code>a<sub>1</sub> ,</code>
      ...<code>,</code>
      <code>P</code><sub><i>n</i></sub> <code>a</code><sub><i>n</i></sub><code>)</code>
    <code>{ return F (a<sub>1</sub> ,</code> ...<code>, a</code><sub><i>n</i></sub><code>); }</code>
  </div>
  <p>is also considered as a candidate function. Similarly, surrogate call functions are added to the set of candidate
  functions for each non-explicit conversion function declared in a base class of T provided the function is not
  hidden within T by another intervening declaration 127 .
  </p>
  <p><span class="ptag" title="16.3.1.1.2 [over.call.object]/3">3</span>
  If such a surrogate call function is selected by overload resolution, the corresponding conversion function will
  be called to convert E to the appropriate function pointer or reference, and the function will then be invoked
  with the arguments of the call. If the conversion function cannot be called (e.g., because of an ambiguity),
  the program is ill-formed.
  </p>
  <p><span class="ptag" title="16.3.1.1.2 [over.call.object]/4">4</span>
  The argument list submitted to overload resolution consists of the argument expressions present in the
  function call syntax preceded by the implied object argument (E) . [Note: When comparing the call against
  the function call operators, the implied object argument is compared against the implicit object parameter of
  the function call operator. When comparing the call against a surrogate call function, the implied object
  argument is compared against the first parameter of the surrogate call function. The conversion function
  from which the surrogate call function was derived will be used in the conversion sequence for that parameter
  since it converts the implied object argument to the appropriate function pointer or reference required by
  that first parameter. —end note ] [Example:
  </p>
<pre class="agh-prog-cpp">
int f1(int);
int f2(float);
typedef int (*fp1)(int);
typedef int (*fp2)(float);
struct A {
  operator fp1() { return f1; }
  operator fp2() { return f2; }
} a;
int i = a(1);     // calls f1 via pointer returned from conversion function
</pre>
  <p>—end example ]</p>
  <p><span class="ptag">footnote 127</span>
  Note that this construction can yield candidate call functions that cannot be differentiated one from the other by overload
  resolution because they have identical declarations or differ only in their return type. The call will be ambiguous if overload
  resolution cannot select a match to the call that is uniquely better than such undifferentiable functions.
  </p>
</div>

<h4 id="sec16.3.2">16.3.1.2 Operators in expressions <span class="stag">[over.match.oper]</span></h4>
<p><span class="ptag" id="sec16.3.1.2p1" title="16.3.1.2 [over.call.oper]/1">1</span>
クラス型か列挙型の被演算子を持たない演算子は、組み込み演算子として Clause 8 に従って解釈される。
[註: 演算子 <code class="agh-prog-cpp">.</code>, <code class="agh-prog-cpp">.*</code>, <code class="agh-prog-cpp">::</code> は、
多重定義できないので常に Clause8 に従って解釈される組み込み演算子である。
演算子 <code class="agh-prog-cpp">:?</code> も多重定義できないが、
第2・第3被演算子がクラス型または列挙型のときこれらに適用される変換は、
この節の規則によって決まる (8.16)。- 註終わり ] [例:
</p>
<pre class="agh-prog-cpp">
struct String {
  String (const String&amp;);
  String (const char*);
  operator const char* ();
};
String operator + (const String&amp;, const String&amp;);


void f() {
  const char* p= "one" + "two"; // どちらの被演算子もクラス型または列挙型ではないので不適格。
  int I = 1 + 1;                // この操作を実行しうるクラス型・列挙型が存在したとしても、
                                // 常に結果は 2 になる。
}
</pre>
<p>- 例終わり ]</p>
<p><span class="ptag" id="sec16.3.1.2p2" title="16.3.1.2 [over.call.oper]/2">2</span>
何れかの被演算子がクラス型または列挙型のとき、
演算子を実装するユーザ定義の演算子関数が宣言されているか、
そうでなければ被演算子を組み込み演算子に合う型に変換するユーザ定義の変換が必要になる。
このとき演算を実行する上でどの演算子関数・組み込み演算子が呼び出されるかが多重定義解決で決まる。
従って、演算子記法は初めに、表 12 に示したような等価な関数呼び出し記法に変形される
(但し <code class="agh-prog-cpp">@</code> は表中に示した各節で述べる演算子のうちの何れかである)。
ただし、被演算子は組み込み演算子 (Clause 8) について既に述べた順序で副作用完了する。
</p>
<table class="normal">
<caption>表 12 - 演算子と関数呼び出し記法の関係</caption>
<tr><th>節</th><th>式</th><th>メンバ関数として</th><th>非メンバ関数として</th></tr>
<tr><td>16.5.1</td><td><code class="agh-prog-cpp">@a  </code></td><td><code class="agh-prog-cpp">(a).operator@ () </code></td><td><code class="agh-prog-cpp">operator@(a)</code></td></tr>
<tr><td>16.5.2</td><td><code class="agh-prog-cpp">a@b </code></td><td><code class="agh-prog-cpp">(a).operator@ (b)</code></td><td><code class="agh-prog-cpp">operator@(a, b)</code></td></tr>
<tr><td>16.5.3</td><td><code class="agh-prog-cpp">a=b </code></td><td><code class="agh-prog-cpp">(a).operator= (b)</code></td><td></td></tr>
<tr><td>16.5.5</td><td><code class="agh-prog-cpp">a[b]</code></td><td><code class="agh-prog-cpp">(a).operator[](b)</code></td><td></td></tr>
<tr><td>16.5.6</td><td><code class="agh-prog-cpp">a-> </code></td><td><code class="agh-prog-cpp">(a).operator->() </code></td><td></td></tr>
<tr><td>16.5.7</td><td><code class="agh-prog-cpp">a@  </code></td><td><code class="agh-prog-cpp">(a).operator@ (0)</code></td><td><code class="agh-prog-cpp">operator@(a, 0)</code></td></tr>
</table>
<p><span class="ptag" id="sec16.3.1.2p3" title="16.3.1.2 [over.call.oper]/3">3</span>
単項演算子 <code class="agh-prog-cpp">@</code> の被演算子の
cv 修飾を除いた型を <code class="agh-prog-cpp">T1</code> とする。
二項演算子 <code class="agh-prog-cpp">@</code> の左被演算子・右被演算子の
cv 修飾を除いた型をそれぞれ <code class="agh-prog-cpp">T1</code>・<code class="agh-prog-cpp">T2</code> とする。
単項演算子と二項演算子について、3種類の候補関数
――指定された<dfn>メンバー候補</dfn> (designated member candidates)、<dfn>非メンバ候補</dfn> (non-member candidates)、<dfn>組み込み候補</dfn> (built-in candidates)――
が以下のようにして構築される。
</p>
<ul>
<li><span class="ptag" id="sec16.3.1.2p3.1" title="16.3.1.2 [over.call.oper]/(3.1)">(3.1)</span>
  <code class="agh-prog-cpp">T1</code> が完全クラス型または現在定義しているクラス型の場合、
  メンバ候補の集合は <code class="agh-prog-cpp">T1::operator@</code> の修飾付き探索 (16.3.1.1.1) の結果とする。
  それ以外の場合は、メンバ候補の集合は空とする。
  </li>
<li><span class="ptag" id="sec16.3.1.2p3.2" title="16.3.1.2 [over.call.oper]/(3.2)">(3.2)</span>
  非メンバ候補の集合は、
  修飾なし関数呼び出しの通常の名前探索 (6.4.2) においてメンバ関数を無視することによって、
  その式の文脈における <code class="agh-prog-cpp">operator@</code> の修飾なし探索を行った結果とする。
  但し、クラス型を持つ被演算子がない場合は、探索結果の非メンバ関数のうち、
  <code class="agh-prog-cpp">T1</code> が列挙型でかつ第1仮引数の型が
  <code class="agh-prog-cpp">T1</code> または "<code class="agh-prog-cpp"><i>cv</i> T1</code> の参照" であるか、
  もし右被演算子が存在すれば <code class="agh-prog-cpp">T2</code> が列挙型でかつ第2仮引数の型が
  <code class="agh-prog-cpp">T2</code> または "<code class="agh-prog-cpp"><i>cv</i> T2</code> の参照" であるような物のみが候補関数である。
  </li>
<li><span class="ptag" id="sec16.3.1.2p3.3" title="16.3.1.2 [over.call.oper]/(3.3)">(3.3)</span>
  演算子 <code class="agh-prog-cpp">,</code>、単項演算子 <code class="agh-prog-cpp">&amp;</code>、演算子 <code class="agh-prog-cpp">-></code> については、
  組み込み候補は空である。それ以外の全ての演算子について、
  組み込み候補は 16.6 で定義される候補演算子関数のうち、
  対象の演算子と比べて以下を満たすものを全て含む。
  <ul>
  <li><span class="ptag" id="sec16.3.1.2p3.3.1" title="16.3.1.2 [over.call.oper]/(3.3.1)">(3.3.1)</span> 同じ名前を持ち、かつ</li>
  <li><span class="ptag" id="sec16.3.1.2p3.3.2" title="16.3.1.2 [over.call.oper]/(3.3.2)">(3.3.2)</span> 同じ個数の被演算子を受け取り、</li>
  <li><span class="ptag" id="sec16.3.1.2p3.3.3" title="16.3.1.2 [over.call.oper]/(3.3.3)">(3.3.3)</span>
    与えられた被演算子から 16.3.3.1 に基づき変換できる型の被演算子を受け取り、かつ
    </li>
  <li><span class="ptag" id="sec16.3.1.2p3.3.4" title="16.3.1.2 [over.call.oper]/(3.3.4)">(3.3.4)</span>
    関数テンプレート特殊化でない非メンバ候補と同じ <span class="syntax">parameter-type-list</span> を持たない。
    <p class="translation-note">関数テンプレート特殊化非メンバ候補 vs 組み込み候補はどうなるのか? これは 16.6 をよく見る必要がある■</p>
    </li>
  </ul>
</li>
</ul>
<p><span class="ptag" id="sec16.3.1.2p4" title="16.3.1.2 [over.call.oper]/4">4</span>
組み込みの代入演算子については、左被演算子の変換は以下のように制限される:
</p>
<ul>
<li><span class="ptag" id="sec16.3.1.2p4.1" title="16.3.1.2 [over.call.oper]/(4.1)">(4.1)</span>
  左被演算子を保持するために一時オブジェクトは導入されず、また</li>
<li><span class="ptag" id="sec16.3.1.2p4.2" title="16.3.1.2 [over.call.oper]/(4.2)">(4.2)</span>
  左被演算子に対して  組み込み候補の第1仮引数の型に合うように左被演算子にユーザ定義変換が適用されることもない。</li>
</ul>
<p><span class="ptag" id="sec16.3.1.2p5" title="16.3.1.2 [over.call.oper]/5">5</span>
その他の演算子については、上記の制限はない。
</p>
<p><span class="ptag" id="sec16.3.1.2p6" title="16.3.1.2 [over.call.oper]/6">6</span>
多重定義解決に用いる候補関数の集合は、メンバー候補、非メンバー候補、組み込み候補の和集合である。
実引数リストは、その演算子の全ての被演算子を含む。
最適な候補関数が 16.3.2, 16.3.3 に基づき選択される<sup>128</sup>。[例:
</p>
<pre class="agh-prog-cpp">
struct A {
  operator int();
};
A operator+(const A&amp;, const A&amp;);
void m() {
  A a, b;
  a + b;      // int(a) + int(b) ではなく operator+(a, b) が選ばれる。
}
</pre>
<p>—end example ]</p>
<p><span class="ptag" id="sec16.3.1.2p7" title="16.3.1.2 [over.call.oper]/7">7</span>
組み込み候補が多重定義解決により選ばれた場合、
先ずクラス型の被演算子は、選ばれた演算関数の対応する仮引数の型に変換される。
但し、ユーザ定義変換列 (16.3.3.1.2) の第2の標準変換列は適用されない。
その後に演算子は対応する組み込み演算子として Clause 8 に従って解釈される。[例:
</p>
<pre class="agh-prog-cpp">
struct X {
  operator double();
};

struct Y {
  operator int*();
};

int *a = Y() + 100.0; // error: pointer arithmetic requires integral operand
int *b = Y() + X();   // error: pointer arithmetic requires integral operand
</pre>
<p>- 例終わり ]</p>
<div class="translation-note">
  「但し、ユーザ定義変換列 (16.3.3.1.2) の第2の標準変換列は適用されない
  (except that the second standard conversion sequence of a user-defined conversion sequence (16.3.3.1.2) is not applied)」
  とはどういうことだろう。2つの解釈がある。
  <ul>
  <li>(a) 選ばれた組み込み候補が第2の標準変換列を必要とするとき、Clause 5 によってチェックされ不適格になるのか、</li>
  <li>(b) それとも、第2の標準変換列を必要とするような組み込み候補は (呼び出し可能でないとして) そもそも多重定義解決で選ばれることがない</li>
  </ul>
  他の規則を探したが、(b) に対応する記述 (組み込み演算子関数に対して第2の標準変換列が恒等変換でなければならない) は未だ見つかっていない。
  ということは、第2の標準変換列を必要とするような組み込み候補が、
  その他の呼び出し可能な候補(メンバ候補・非メンバ候補)を差し置いて選択される可能性が依然としてあり、
  この時 (a) になる気がするが不自然だ。実際に試してみる。

  <p>試した結果そもそも gcc/clang にバグがある様だ。
  第2標準変換列が恒等変換でなければならないという規則は C++03 にはなく C++14 で追加された様だ。
  gcc では -std=c++?? に関係なく常に C++14 以降の動作である。
  clang では -std=c++?? に関係なく常に C++11 以前の動作である。
  </p>
<pre class="agh-prog-cpp">
// Example from N4140 13.3.1.2/7, N4569 16.3.1.2/7
//
// gcc emits diagnostics as expected.
// clang compiles without diagnostics.

struct X { operator double() {return 0.0;} };
struct Y { operator int*() {return 0;} };
int main() {
  int* a = Y() + 100.0;
  int* b = Y() + X();
  (void) a;
  (void) b;
}
</pre>
  <p>取り敢えず少なくとも gcc の方が N4659 に対応しているようなのでこれで試す。</p>
<pre class="agh-prog-cpp">
struct A {
  int operator-(A const&amp;) {return 2;} // #1
  friend int operator*(A, A) {return 3;}      // #2
};
int operator+(A, A) {return 1;} // #3
struct X { operator A() const {return A();} };
struct Y { operator A() const {return A();} };

void test1() {
  X x;
  Y y;
  (void) (x + y); // OK: #3 operator+ は非メンバ候補
  (void) (x - y); // Error: #1 operator- はメンバ候補には挙がらない
  (void) (x * y); // Error: #2 operator* は ADL でないと見えない
}

struct B { B(int*) {} };
int operator+(B, int) {return 4;} // #4
struct N { operator double() const {return 0.0;} };

// #5 は組み込み演算子 operator+(int* int) とする。

void test2() {
  int* p = nullptr;
  N n;
  (void) (p + n); // 実引数: (int*, N), 非メンバ候補: #4 int (B, int), 組み込み候補: int* (int*, int)
  // → gcc では p + n は int になる。これはグレー。
  // → clang では p + n は int* になる。どうやら p + (int) (double) n になっている。しかしこれは Clause 5 で禁止されるはずだ。
}
</pre>
  <p>GCC は (b) の解釈のようだ。
  しかし再度探しても、ユーザ定義変換列の中の第2標準変換列が組込候補に対して恒等変換でなければならなという記述は見つからない。
  これの根拠は何処にあるのか?</p>
  <p>そもそもこの規則が C++14 で追加された経緯も確認しておくべきだろう。
  <del>この規則が追加された時に慎重に考えられずに適当に追加された可能性が高い気がする。</del>
  →<a href="http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1687">CWG 1687</a> で理由付きで変更されている。尤もだ。
  うーん。これを見る限り、多重定義解決の過程では第2標準変換列として非自明なものを許すが、
  最終的なチェックを Clause 5 で行うために取り敢えず第2標準変換列の手前まで変換を行うという事に見える。
  ということは (a) ということのように思われる。
  </p>
  <div class="en">
    <p>1687. Conversions of operands of built-in operators</p>
    <p>Section: 13.3.1.2  [over.match.oper]     Status: C++14     Submitter: Richard Smith     Date: 2013-05-17</p>
    <p>[Moved to DR at the February, 2014 meeting.]</p>
    <p>Consider an example like:</p>
<pre class="agh-prog-cpp">
struct Y {
  operator int*();
};

extern int *p;
int *a = p + 100.0;   // #1
int *b = Y() + 100.0; // #2
</pre>
    <p>#1 is ill-formed because it violates the requirement of 5.7 [expr.add] that the non-pointer operand have integral or enumeration type.
    It appears that #2 is well-formed, however, because 13.3.1.2 [over.match.oper] paragraph 7 says,</p>
    <blockquote>
    If a built-in candidate is selected by overload resolution, the operands are converted to the types of
    the corresponding parameters of the selected operation function. Then the operator is treated as the
    corresponding built-in operator and interpreted according to Clause 5 [expr].
    </blockquote>
    <p>In this case, the selected operation function is</p>
<pre class="agh-prog-cpp">
int *operator+(int *, std::ptrdiff_t)
</pre>
    <p>100.0 is thus converted to std::ptrdiff_t before reaching 5.7 [expr.add].</p>
    <p>This problem could be addressed by restricting the conversion to the class or enumeration operand rather than both operands.</p>
  </div>
  またもし (b) の様にしようとすると viable かどうかを判定する時に
  Clause 5 を引っ張り出して来なければならず複雑になる。
</div>
<p><span class="ptag" id="sec16.3.1.2p8" title="16.3.1.2 [over.call.oper]/8">8</span>
演算子 <code class="agh-prog-cpp">-></code> の第2被演算子は、多重定義解決の際に無視され、
関数 <code class="agh-prog-cpp">operator-></code> が呼ばれるときの実引数にはならない。
関数 <code class="agh-prog-cpp">operator-></code> の戻り値に対して、
再度演算子 <code class="agh-prog-cpp">-></code> が元々の第2非演算子と共に適用される<sup>129</sup>。
</p>
<p><span class="ptag" id="sec16.3.1.2p9" title="16.3.1.2 [over.call.oper]/9">9</span>
演算子 <code class="agh-prog-cpp">,</code>、単項演算子 <code class="agh-prog-cpp">&amp;</code>、演算子 <code class="agh-prog-cpp">-></code> について、
呼び出し可能関数がない場合には演算子は組み込み演算子と見なされ Clause 8 によって解釈される。
</p>
<p><span class="ptag" id="sec16.3.1.2p10" title="16.3.1.2 [over.call.oper]/10">10</span>
[註: 以下の例に示したように、式中の演算子の名前探索の規則は、関数呼び出しにおける演算子関数の名前探索と異なる:
</p>
<pre class="agh-prog-cpp">
struct A { };
void operator + (A, A);

struct B {
  void operator + (B);
  void f ();
};

A a;

void B::f() {
  operator+ (a,a);  // error: グローバルの演算子はメンバによって隠蔽される。
  a + a;            // OK: グローバルの operator+ が呼び出される。
}
</pre>
<p>- 註終わり ]</p>
<p><span class="ptag" id="footnote128">footnote 128</span>
候補関数の集合が空のとき、多重定義解決は失敗である。
</p>
<p class="translation-note">
16.3.1.2/9 については候補関数が空であったとしても、
Clause 8 へ行くので失敗ではないのではないか。■
</p>
<p><span class="ptag" id="footnote129">footnote 129</span>
関数 <code class="agh-prog-cpp">operator-></code> の戻り値がクラス型のとき、
更にもう一つの <code class="agh-prog-cpp">operator-></code> を選択して呼び出すことになる。
この処理は <code class="agh-prog-cpp">operator-></code> が非クラス型の値を返すまで続く。
</p>
<p class="translation-note">
無限ループになった場合に処理系はどうすれば良いか規定されていない。
つまり、correct execution が要求されるのでは?■
</p>

<div class="en">
  <p><span class="ptag" title="16.3.1.2 [over.call.oper]/1">1</span>
  If no operand of an operator in an expression has a type that is a class or an enumeration, the operator
  is assumed to be a built-in operator and interpreted according to Clause 8. [Note: Because . , .* , and ::
  cannot be overloaded, these operators are always built-in operators interpreted according to Clause 8. ?:
  cannot be overloaded, but the rules in this subclause are used to determine the conversions to be applied to
  the second and third operands when they have class or enumeration type (8.16). —end note ] [Example:
  </p>
<pre class="agh-prog-cpp">
struct String {
  String (const String&amp;);
  String (const char*);
  operator const char* ();
};
String operator + (const String&amp;, const String&amp;);

void f() {
  const char* p= "one" + "two"; // ill-formed because neither operand has class or enumeration type
  int I = 1 + 1;                // always evaluates to 2 even if class or enumeration types exist
                                // that would perform the operation.
}
</pre>
  <p>—end example ]</p>
  <p><span class="ptag" title="16.3.1.2 [over.call.oper]/2">2</span>
  If either operand has a type that is a class or an enumeration, a user-defined operator function might be
  declared that implements this operator or a user-defined conversion can be necessary to convert the operand to
  a type that is appropriate for a built-in operator. In this case, overload resolution is used to determine which
  operator function or built-in operator is to be invoked to implement the operator. Therefore, the operator
  notation is first transformed to the equivalent function-call notation as summarized in Table 12 (where @
  denotes one of the operators covered in the specified subclause). However, the operands are sequenced in the
  order prescribed for the built-in operator (Clause 8).
  </p>
  <table class="normal">
  <caption>Table 12 — Relationship between operator and function call notation</caption>
  <tr><th>Subclause</th><th>Expression</th><th>As member function</th><th>As non-member function</th></tr>
  <tr><td>16.5.1</td><td><code class="agh-prog-cpp">@a  </code></td><td><code class="agh-prog-cpp">(a).operator@ () </code></td><td><code class="agh-prog-cpp">operator@(a)</code></td></tr>
  <tr><td>16.5.2</td><td><code class="agh-prog-cpp">a@b </code></td><td><code class="agh-prog-cpp">(a).operator@ (b)</code></td><td><code class="agh-prog-cpp">operator@(a, b)</code></td></tr>
  <tr><td>16.5.3</td><td><code class="agh-prog-cpp">a=b </code></td><td><code class="agh-prog-cpp">(a).operator= (b)</code></td><td></td></tr>
  <tr><td>16.5.5</td><td><code class="agh-prog-cpp">a[b]</code></td><td><code class="agh-prog-cpp">(a).operator[](b)</code></td><td></td></tr>
  <tr><td>16.5.6</td><td><code class="agh-prog-cpp">a-> </code></td><td><code class="agh-prog-cpp">(a).operator->() </code></td><td></td></tr>
  <tr><td>16.5.7</td><td><code class="agh-prog-cpp">a@  </code></td><td><code class="agh-prog-cpp">(a).operator@ (0)</code></td><td><code class="agh-prog-cpp">operator@(a, 0)</code></td></tr>
  </table>
  <p><span class="ptag" title="16.3.1.2 [over.call.oper]/3">3</span>
  For a unary operator @ with an operand of a type whose cv-unqualified version is T1 , and for a binary operator
  @ with a left operand of a type whose cv-unqualified version is T1 and a right operand of a type whose
  cv-unqualified version is T2 , three sets of candidate functions, designated member candidates, non-member
  candidates and built-in candidates, are constructed as follows:
  </p>
  <ul>
  <li><span class="ptag" title="16.3.1.2 [over.call.oper]/(3.1)">(3.1)</span>
    If T1 is a complete class type or a class currently being defined, the set of member candidates is the
    result of the qualified lookup of T1::operator@ (16.3.1.1.1); otherwise, the set of member candidates
    is empty.
    </li>
  <li><span class="ptag" title="16.3.1.2 [over.call.oper]/(3.2)">(3.2)</span>
    The set of non-member candidates is the result of the unqualified lookup of operator@ in the context of
    the expression according to the usual rules for name lookup in unqualified function calls (6.4.2) except
    that all member functions are ignored. However, if no operand has a class type, only those non-member
    functions in the lookup set that have a first parameter of type T1 or “reference to cv T1 ”, when T1 is
    an enumeration type, or (if there is a right operand) a second parameter of type T2 or “reference to
    cv T2”, when T2 is an enumeration type, are candidate functions.
    </li>
  <li><span class="ptag" title="16.3.1.2 [over.call.oper]/(3.3)">(3.3)</span>
    For the operator , , the unary operator & , or the operator -> , the built-in candidates set is empty.
    For all other operators, the built-in candidates include all of the candidate operator functions defined
    in 16.6 that, compared to the given operator,
    <ul>
    <li><span class="ptag" title="16.3.1.2 [over.call.oper]/(3.3.1)">(3.3.1)</span> have the same operator name, and</li>
    <li><span class="ptag" title="16.3.1.2 [over.call.oper]/(3.3.2)">(3.3.2)</span> accept the same number of operands, and</li>
    <li><span class="ptag" title="16.3.1.2 [over.call.oper]/(3.3.3)">(3.3.3)</span>
      accept operand types to which the given operand or operands can be converted according to
      16.3.3.1, and
      </li>
    <li><span class="ptag" title="16.3.1.2 [over.call.oper]/(3.3.4)">(3.3.4)</span>
      do not have the same parameter-type-list as any non-member candidate that is not a function
      template specialization.
      </li>
    </ul>
  </li>
  </ul>
  <p><span class="ptag" title="16.3.1.2 [over.call.oper]/4">4</span>
  For the built-in assignment operators, conversions of the left operand are restricted as follows:
  </p>
  <ul>
  <li><span class="ptag" title="16.3.1.2 [over.call.oper]/(4.1)">(4.1)</span>
    no temporaries are introduced to hold the left operand, and</li>
  <li><span class="ptag" title="16.3.1.2 [over.call.oper]/(4.2)">(4.2)</span>
    no user-defined conversions are applied to the left operand to achieve a type match with the left-most
    parameter of a built-in candidate.
    </li>
  </ul>
  <p><span class="ptag" title="16.3.1.2 [over.call.oper]/5">5</span>
  For all other operators, no such restrictions apply.
  </p>
  <p><span class="ptag" title="16.3.1.2 [over.call.oper]/6">6</span>
  The set of candidate functions for overload resolution is the union of the member candidates, the non-member
  candidates, and the built-in candidates. The argument list contains all of the operands of the operator. The
  best function from the set of candidate functions is selected according to 16.3.2 and 16.3.3. 128 [Example:
  </p>
<pre class="agh-prog-cpp">
struct A {
  operator int();
};
A operator+(const A&amp;, const A&amp;);
void m() {
  A a, b;
  a + b;      // operator+(a, b) chosen over int(a) + int(b)
}
</pre>
  <p>—end example ]</p>
  <p><span class="ptag" title="16.3.1.2 [over.call.oper]/7">7</span>
  If a built-in candidate is selected by overload resolution, the operands of class type are converted to the
  types of the corresponding parameters of the selected operation function, except that the second standard
  conversion sequence of a user-defined conversion sequence (16.3.3.1.2) is not applied. Then the operator is
  treated as the corresponding built-in operator and interpreted according to Clause 8. [Example:
  </p>
<pre class="agh-prog-cpp">
struct X {
  operator double();
};

struct Y {
  operator int*();
};

int *a = Y() + 100.0; // error: pointer arithmetic requires integral operand
int *b = Y() + X();   // error: pointer arithmetic requires integral operand
</pre>
  <p>—end example ]</p>
  <p><span class="ptag" title="16.3.1.2 [over.call.oper]/8">8</span>
  The second operand of operator -> is ignored in selecting an operator-> function, and is not an argument
  when the operator-> function is called. When operator-> returns, the operator -> is applied to the value
  returned, with the original second operand. 129
  </p>
  <p><span class="ptag" title="16.3.1.2 [over.call.oper]/9">9</span>
  If the operator is the operator , , the unary operator & , or the operator -> , and there are no viable functions,
  then the operator is assumed to be the built-in operator and interpreted according to Clause 8.
  </p>
  <p><span class="ptag" title="16.3.1.2 [over.call.oper]/10">10</span>
  [Note: The lookup rules for operators in expressions are different than the lookup rules for operator function
  names in a function call, as shown in the following example:
  </p>
<pre class="agh-prog-cpp">
struct A { };
void operator + (A, A);

struct B {
  void operator + (B);
  void f ();
};

A a;

void B::f() {
  operator+ (a,a);  // error: global operator hidden by member
  a + a;            // OK: calls global operator+
}
</pre>
  <p>—end note ]</p>
  <p><span class="ptag">footnote 128</span>
   If the set of candidate functions is empty, overload resolution is unsuccessful.
  </p>
  <p><span class="ptag">footnote 129</span>
  If the value returned by the operator-> function has class type, this may result in selecting and calling another operator->
  function. The process repeats until an operator-> function returns a value of non-class type.
  </p>
</div>

<h4 id="sec16.3.1.3">16.3.1.3 Initialization by constructor <span class="stag">[over.match.ctor]</span></h4>
<p><span class="ptag" id="sec16.3.1.3p1" title="16.3.1.3 [over.match.ctor]/1">1</span>
クラス型のオブジェクトを、
直接初期化 (11.6) または同じ型または派生クラス型からコピー初期化 (11.6) または既定初期化 (11.6) するとき、
多重定義解決でそのコンストラクを選ぶ。
コピー初期化の文脈にない直接初期化・既定初期化について、
候補関数は初期化されるオブジェクトのクラスの全てのコンストラクタである。
コピー初期化について、
候補関数はそのクラスの全ての変換コンストラクタ (15.3.1) である。
実引数リストは <span class="syntax">initializer</span> 中の、
<span class="syntax">expression-list</span> または <span class="syntax">assignment-expression</span> である。
</p>

<div class="en">
  <p><span class="ptag" title="16.3.1.3 [over.match.ctor]/1">1</span>
  When objects of class type are direct-initialized (11.6), copy-initialized from an expression of the same or
  a derived class type (11.6), or default-initialized (11.6), overload resolution selects the constructor. For
  direct-initialization or default-initialization that is not in the context of copy-initialization, the candidate
  functions are all the constructors of the class of the object being initialized. For copy-initialization, the
  candidate functions are all the converting constructors (15.3.1) of that class. The argument list is the
  expression-list or assignment-expression of the initializer.
  </p>
</div>

<h4 id="sec16.3.1.4">16.3.1.4 Copy-initialization of class by user-defined conversion <span class="stag">[over.match.copy]</span></h4>
<h4 id="sec16.3.1.5">16.3.1.5 Initialization by conversion function <span class="stag">[over.match.conv]</span></h4>
<h4 id="sec16.3.1.6">16.3.1.6 Initialization by conversion function for direct reference binding <span class="stag">[over.match.ref]</span></h4>
<h4 id="sec16.3.1.7">16.3.1.7 Initialization by list-initialization <span class="stag">[over.match.list]</span></h4>
<h4 id="sec16.3.1.8">16.3.1.8 Class template argument deduction <span class="stag">[over.match.class.deduct]</span></h4>
<h3 id="sec16.3.2">16.3.2 Viable functions <span class="stag">[over.match.viable]</span></h3>
<p><span class="ptag" id="sec16.3.2p1" title="16.3.2 [over.match.viable]/1">1</span>
現在の文脈に対して候補関数の集合を求めた後 (16.3.1)、その中から呼び出し可能関数の集合が選ばれる。
後で、実引数の変換列 (16.3) を比べることによって、この集合の中からできるだけ実引数が合致する最適な関数が選択される。
呼び出し可能関数の選択では、(変換列の優先度を除く) 実引数と関数の仮引数の関係が考慮される。
</p>
<p><span class="ptag" id="sec16.3.2p2" title="16.3.2 [over.match.viable]/2">2</span>
先ず、候補関数が呼び出し可能関数であるためには、
実引数の数に対して仮引数が十分な数ある必要がある。
</p>
<ul>
<li><span class="ptag" id="sec16.3.2p2.1" title="16.3.2 [over.match.viable]/(2.1)">(2.1)</span> <i>m</i> 個の実引数があるとき、丁度 <i>m</i> 個の仮引数を持つ候補関数は呼び出し可能である。</li>
<li><span class="ptag" id="sec16.3.2p2.2" title="16.3.2 [over.match.viable]/(2.2)">(2.2)</span>
  <i>m</i> 個より少ない仮引数を持つ候補関数は、仮引数リスト (11.3.5) に省略記号を持つ時に限り呼び出し可能である。
  多重定義解決の過程で、対応する仮引数のない実引数は「省略記号に一致する」として扱う (16.3.3.1.3)。</li>
<li><span class="ptag" id="sec16.3.2p2.3" title="16.3.2 [over.match.viable]/(2.3)">(2.3)</span>
  <i>m</i> 個より多くの仮引数を持つ候補関数は、<i>m+1</i> 個目の仮引数が既定の実引数 (11.3.6) を持つときに限り呼び出し可能である<sup>130</sup>。
  多重定義解決の過程では、仮引数リストは丁度 <i>m</i> 個の仮引数を持つように右端を切除して用いる。</li>
</ul>
<p><span class="ptag" id="sec16.3.2p3" title="16.3.2 [over.match.viable]/3">3</span>
次に、<code class="agh-prog-cpp">F</code> が呼び出し可能関数であるためには、
それぞれの実引数を対応する <code class="agh-prog-cpp">F</code> の仮引数に変換する暗黙変換列 (16.3.3.1) が存在する必要がある。
仮引数が参照型の場合は、暗黙変換列には参照の束縛も含まれる。
従って、非 const 左辺値参照が rvalue に束縛できないこと、
また右辺値参照が lvalue に束縛できないことは、
関数の呼び出し可能性に影響を与える (16.3.3.1.4)。
</p>
<p><span class="ptag" id="footenote130">foonote 130</span>
この時、11.3.6 により <i>m+1</i> 個目以降の仮引数も既定の実引数を持っている。
</p>
<p class="translation-note">
原文 viable functions はここでは<i>呼び出し可能関数</i>と訳すことにした。
JIS C++ では<i>二次候補関数</i>と訳していることに注意する。
</p>
<div class="en">
  <p><span class="ptag" title="16.3.2 [over.match.viable]/1">1</span>
  From the set of candidate functions constructed for a given context (16.3.1), a set of viable functions is
  chosen, from which the best function will be selected by comparing argument conversion sequences for the
  best fit (16.3.3). The selection of viable functions considers relationships between arguments and function
  parameters other than the ranking of conversion sequences.
  </p>
  <p><span class="ptag" title="16.3.2 [over.match.viable]/2">2</span>
  First, to be a viable function, a candidate function shall have enough parameters to agree in number with
  the arguments in the list.
  </p>
  <ul>
  <li><span class="ptag" title="16.3.2 [over.match.viable]/(2.1)">(2.1)</span> If there are m arguments in the list, all candidate functions having exactly m parameters are viable.</li>
  <li><span class="ptag" title="16.3.2 [over.match.viable]/(2.2)">(2.2)</span> A candidate function having fewer than m parameters is viable only if it has an ellipsis in its parameter
    list (11.3.5). For the purposes of overload resolution, any argument for which there is no corresponding
    parameter is considered to “match the ellipsis” (16.3.3.1.3) .</li>
  <li><span class="ptag" title="16.3.2 [over.match.viable]/(2.3)">(2.3)</span> A candidate function having more than m parameters is viable only if the (m+1)-st parameter has a
    default argument (11.3.6). 130 For the purposes of overload resolution, the parameter list is truncated
    on the right, so that there are exactly m parameters.</li>
  </ul>
  <p><span class="ptag" title="16.3.2 [over.match.viable]/3">3</span>
  Second, for F to be a viable function, there shall exist for each argument an implicit conversion se-
  quence (16.3.3.1) that converts that argument to the corresponding parameter of F . If the parameter
  has reference type, the implicit conversion sequence includes the operation of binding the reference, and the
  fact that an lvalue reference to non- const cannot be bound to an rvalue and that an rvalue reference cannot
  be bound to an lvalue can affect the viability of the function (see 16.3.3.1.4).
  </p>
  <p><span class="ptag">foonote 130</span>
  According to 11.3.6, parameters following the (m+1)-st parameter must also have default arguments.
  </p>
</div>

<h3 id="sec16.3.3">16.3.3 Best viable function <span class="stag">[over.match.best]</span></h3>
<p><span class="ptag" id="sec16.3.3p1" title="16.3.3 [over.match.best]/1">1</span>
<span class="tcomment">呼び出し可能関数 <code class="agh-prog-cpp">F</code> に対して</span>
<span class="ICS">ICS<i>i</i>(<code class="agh-prog-cpp">F</code>)</span> を次のように定義する:</p>
<ul>
<li><span class="ptag" id="sec16.3.3p1.1" title="16.3.3 [over.match.best]/(1.1)">(1.1)</span>
  <code class="agh-prog-cpp">F</code> が静的メンバ関数の場合は、任意の関数 <code class="agh-prog-cpp">G</code> について、
  <span class="ICS">ICS<i>1</i>(<code class="agh-prog-cpp">F</code>)</span> は
  <span class="ICS">ICS<i>1</i>(<code class="agh-prog-cpp">G</code>)</span> に比べて良くも悪くもなく、
  また <span class="ICS">ICS<i>1</i>(<code class="agh-prog-cpp">G</code>)</span> は
  <span class="ICS">ICS<i>1</i>(<code class="agh-prog-cpp">F</code>)</span> に比べて良くも悪くもない<sup>131</sup>。
  それ以外の場合は、</li>
<li><span class="ptag" id="sec16.3.3p1.2" title="16.3.3 [over.match.best]/(1.2)">(1.2)</span>
  <span class="ICS">ICS<i>i</i>(<code class="agh-prog-cpp">F</code>)</span> は、
  <i>i</i> 番目の実引数から <code class="agh-prog-cpp">F</code> の <i>i</i> 番目の仮引数型への暗黙変換列を表す。
  16.3.3.1 で暗黙変換列を定義し、16.3.3.2 で或る暗黙変換列が他の暗黙変換列と比べて良いか悪いかを定義する。
  </li>
</ul>
<p>その上で、次が満たされるときに、
呼び出し可能関数 <code class="agh-prog-cpp">F1</code> が
<code class="agh-prog-cpp">F2</code> よりも良いと定義する。
即ち、全ての実引数 <i>i</i> について
<span class="ICS">ICS<i>i</i>(<code class="agh-prog-cpp">F1</code>)</span> が
<span class="ICS">ICS<i>i</i>(<code class="agh-prog-cpp">F2</code>)</span> より悪くなく、
かつ</p>
<ul>
<li><span class="ptag" id="sec16.3.3p1.3" title="16.3.3 [over.match.best]/(1.3)">(1.3)</span>
  或る実引数 <i>j</i> について
  <span class="ICS">ICS<i>j</i>(<code class="agh-prog-cpp">F1</code>)</span> が
  <span class="ICS">ICS<i>j</i>(<code class="agh-prog-cpp">F2</code>)</span> より良いか、
  そうでなければ</li>
<li><span class="ptag" id="sec16.3.3p1.4" title="16.3.3 [over.match.best]/(1.4)">(1.4)</span>
  ユーザ定義変換による初期化の文脈 (11.6, 16.3.1.5, 16.3.1.6) で、
  <code class="agh-prog-cpp">F1</code> の戻り値の型から目的の型 (初期化されるオブジェクトの型) への標準変換列が、
  <code class="agh-prog-cpp">F2</code> の戻り値の型から目的の型への標準変換列より良い [例:
<pre class="agh-prog-cpp">
struct A {
  A();
  operator int();
  operator double();
} a;
int i = a;    // 変換の必要のない a.operator int() の方が、
              // 後で int に変換する必要のある a.operator double() よりも良い。
float x = a;  // 曖昧: どちらの選択肢も変換を必要とし、
              // 何れかが他方より良いということはない。
</pre>
  - 例終わり ] か、そうでなければ</li>
<li><span class="ptag" id="sec16.3.3p1.5" title="16.3.3 [over.match.best]/(1.5)">(1.5)</span>
  関数の参照への変換関数を通して参照を直接の束縛により初期化する文脈 (16.3.1.6) で、
  <code class="agh-prog-cpp">F1</code> が初期化される参照と同じ種類の参照 (つまり右辺値参照または左辺値参照) であり、
  <code class="agh-prog-cpp">F2</code> がそうでない [例:
<pre class="agh-prog-cpp">
template &lt;class T&gt; struct A {
  operator T&amp;();  // #1
  operator T&amp;&amp;(); // #2
};
typedef int Fn();
A&lt;Fn&gt; a;
Fn&amp; lf = a;       // #1 が呼び出される
Fn&amp;&amp; rf = a;      // #2 が呼び出される
</pre>
  - 例終わり ] か、そうでなければ</li>
<li><span class="ptag" id="sec16.3.3p1.6" title="16.3.3 [over.match.best]/(1.6)">(1.6)</span>
  <code class="agh-prog-cpp">F1</code> が関数テンプレートの特殊化ではなく、
  <code class="agh-prog-cpp">F2</code> が関数テンプレートの特殊化であるか、
  そうでなければ</li>
<li><span class="ptag" id="sec16.3.3p1.7" title="16.3.3 [over.match.best]/(1.7)">(1.7)</span>
  <code class="agh-prog-cpp">F1</code> と <code class="agh-prog-cpp">F2</code> が関数テンプレートの特殊化であり、
  17.5.6.2 の半順序規則に基いて
  <code class="agh-prog-cpp">F1</code> の関数テンプレートが
  <code class="agh-prog-cpp">F2</code> の関数テンプレートに比べてより特殊であるか、
  そうでなければ
  </li>
<li><span class="ptag" id="sec16.3.3p1.8" title="16.3.3 [over.match.best]/(1.8)">(1.8)</span>
  <code class="agh-prog-cpp">F1</code> が deduction-guide (16.3.1.8) によって生成され、
  <code class="agh-prog-cpp">F2</code> がそうでないか、
  そうでなければ</li>
<li><span class="ptag" id="sec16.3.3p1.9" title="16.3.3 [over.match.best]/(1.9)">(1.9)</span>
  <code class="agh-prog-cpp">F1</code> が copy deduction candidate (16.3.1.8) で
  <code class="agh-prog-cpp">F2</code> がそうでないか、
  そうでなければ</li>
<li><span class="ptag" id="sec16.3.3p1.10" title="16.3.3 [over.match.best]/(1.10)">(1.10)</span>
  <code class="agh-prog-cpp">F1</code> が非テンプレートコンストラクタで
  <code class="agh-prog-cpp">F2</code> がコンストラクタテンプレートによって生成される。[例:
<pre class="agh-prog-cpp">
template &lt;class T&gt; struct A {
  using value_type = T;
  A(value_type);    // #1
  A(const A&amp;);      // #2
  A(T, T, int);     // #3
  template&lt;class U&gt;
    A(int, T, U);   // #4
  // #5 を copy deduction candidate A(A) とする。
};

A x(1, 2, 3);       // 非テンプレートコンストラクタから生成された #3 が使われる

template &lt;class T&gt;
A(T) -&gt; A&lt;T&gt;;       // #6, #5 に比べて特殊でない

A a(42);            // #6 で A&lt;int&gt; と推論され #1 で初期化される
A b = a;            // #5 で A&lt;int&gt; と推論され #2 で初期化される

template &lt;class T&gt;
A(A&lt;T&gt;) -&gt; A&lt;A&lt;T&gt;&gt;; // #7, #5 と同程度に特殊

A b2 = a;           // #7 で A&lt;A&lt;int&gt;&gt; と推論され #1 で初期化される
</pre>
  - 例終わり ]
</li>
</ul>
<p class="translation-note">#7 の振る舞いについて確認する必要がある。何故 #5 に打ち勝つのか?</p>
<p class="translation-note">上記の二項関係は「より良い」という字面に反していいかげんな関係である。
つまり <code>better(F, G) := P1(F, G) || ... || Pn(F, G)</code>
(但し <code>P1, ..., Pn</code> は前順序を与える?) の形式をしているが、
この時 <code>better(F, G)</code> と <code>worse(F, G) := better(G, F)</code> は排他的にはなっていない。
つまり、互いに他方よりも良くかつ悪いという場合がある (全順序律を満たさない)。
もちろん、互いに他方より良くも悪くもないという場合もある (反対称律を満たさない)。
推移律はどうか? うーん…もう少し後でちゃんと考える必要がある…。
</p>
<p><span class="ptag" id="sec16.3.3p2" title="16.3.3 [over.match.best]/2">2</span>
他の全ての呼び出し可能関数よりも良い呼び出し可能関数が一意に存在する場合、
それが多重定義解決によって選ばれる。それ以外の場合はその呼出は不適格である<sup>132</sup>。 [例:
</p>
<pre class="agh-prog-cpp">
void Fcn(const int*, short);
void Fcn(int*, int);

int i;
short s = 0;

void f() {
  Fcn(&amp;i, s);     // 曖昧。何故なら &amp;i → int* は &amp;i → const int* より良く、
                  // 同時に s → short が s → int より良い。

  Fcn(&amp;i, 1L);    // Fcn(int*, int) が呼び出される。何故なら &amp;i → int* は &amp;i → const int* より良く、
                  // 1L → short と 1L → int はどちらが良いわけでもない。

  Fcn(&amp;i, 'c');   // Fcn(int*, int) が呼び出される。何故なら &amp;i → int* は &amp;i → const int* より良く、
                  // c → int は c → short より良い。
}
</pre>
<p>- 例終わり ]</p>
<p><span class="ptag" id="sec16.3.3p3" title="16.3.3 [over.match.best]/3">3</span>
最良の呼び出し可能関数が複数の宣言を持つ関数に決まった場合、
関数を呼び出し可能にした或る既定の実引数を
2つ以上の宣言 (または using 宣言の場合、それが指し示す宣言) が指定したとき
プログラムは不適格である。[例:
</p>
<pre class="agh-prog-cpp">
namespace A {
  extern "C" void f(int = 5);
}
namespace B {
  extern "C" void f(int = 5);
}

using A::f;
using B::f;

void use() {
  f(3); // OK, 呼び出し可能であるために既定の実引数は使われなかった
  f();  // Error: 既定の実引数が2回見つかった
}
</pre>
<p>- 例終わり ]</p>
<p class="translation-note">
原文 a default argument that made the function viable は微妙。
Viable functions の所では <i>m+1</i> 番目の既定の実引数についてしか述べられていない。
しかし、ここでは <i>m+1</i> 番目以降の全ての実引数について述べているはずである
(不定冠詞 a が用いられているのはそれを示唆する)。
</p>
<p class="translation-note"><code class="agh-prog-cpp">extern "C"</code> がついているので、
<code class="agh-prog-cpp">A::f</code> と <code class="agh-prog-cpp">B::f</code> は同一の関数?
と思ったがそのようなことは何処かに書かれていただろうか?
</p>
<p><span class="ptag" id="footnote131">footnote 131</span>
関数が静的メンバ関数の場合は、第一引数 (つまり暗黙オブジェクト実引数) は、
その関数が他の関数より良いか悪いかの判断には寄与しないことを表す。
</p>
<p><span class="ptag" id="footnote132">footnote 132</span>
最適な呼び出し可能関数の決定アルゴリズムは呼び出し可能関数の数について線形時間になる。
単純な勝ち抜き戦によってどの対戦相手と比べても悪くない関数 <code class="agh-prog-cpp">W</code> を決める。
<code class="agh-prog-cpp">W</code> と直接対戦しなかった関数 <code class="agh-prog-cpp">F</code> が
<code class="agh-prog-cpp">W</code> より悪くないという可能性もあるが、
<span class="tcomment"><code class="agh-prog-cpp">F</code> が最終的に残っていないということから</span>
勝ち抜き戦の途中で <code class="agh-prog-cpp">F</code> が
<code class="agh-prog-cpp">F</code> より悪くない別の関数 <code class="agh-prog-cpp">G</code> と対戦しているはずなので、
<code class="agh-prog-cpp">F</code> は最良の呼び出し可能関数にはなりえない。
従って <code class="agh-prog-cpp">W</code> が最良の呼び出し可能関数であるか、そのようなものは存在しないかである。
そこで呼び出し可能関数に対して2回目の走査を行い
<code class="agh-prog-cpp">W</code> が他の全ての呼び出し可能関数より良いかどうかを確かめる。
</p>
<p class="translation-note">より良いか悪いかは変な二項関係なので2回目の走査は必要である。</p>

<div class="en">
  <p><span class="ptag" title="16.3.3 [over.match.best]/1">1</span> Define ICSi(F) as follows:</p>
  <ul>
  <li><span class="ptag" title="16.3.3 [over.match.best]/(1.1)">(1.1)</span>
    If F is a static member function, ICS1( F ) is defined such that ICS1( F ) is neither better nor worse than
    ICS1( G ) for any function G , and, symmetrically, ICS1( G ) is neither better nor worse than ICS1( F ); 131
    otherwise,</li>
  <li><span class="ptag" title="16.3.3 [over.match.best]/(1.2)">(1.2)</span>
    let ICSi( F ) denote the implicit conversion sequence that converts the i-th argument in the list to the
    type of the i-th parameter of viable function F . 16.3.3.1 defines the implicit conversion sequences and
    16.3.3.2 defines what it means for one implicit conversion sequence to be a better conversion sequence
    or worse conversion sequence than another.</li>
  </ul>
  <p>Given these definitions, a viable function F1 is defined to be a better function than another viable function
  F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>
  <ul>
  <li><span class="ptag" title="16.3.3 [over.match.best]/(1.3)">(1.3)</span> for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that,</li>
  <li><span class="ptag" title="16.3.3 [over.match.best]/(1.4)">(1.4)</span>
    the context is an initialization by user-defined conversion (see 11.6, 16.3.1.5, and 16.3.1.6) and the
    standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the
    entity being initialized) is a better conversion sequence than the standard conversion sequence from the
    return type of F2 to the destination type [Example:
<pre class="agh-prog-cpp">
struct A {
  A();
  operator int();
  operator double();
} a;
int i = a;    // a.operator int() followed by no conversion is better than
              // a.operator double() followed by a conversion to int
float x = a;  // ambiguous: both possibilities require conversions,
              // and neither is better than the other
</pre>
    —end example ] or, if not that,</li>
  <li><span class="ptag" title="16.3.3 [over.match.best]/(1.5)">(1.5)</span>
    the context is an initialization by conversion function for direct reference binding (16.3.1.6) of a reference
    to function type, the return type of F1 is the same kind of reference (i.e. lvalue or rvalue) as the
    reference being initialized, and the return type of F2 is not [Example:
<pre class="agh-prog-cpp">
template &lt;class T&gt; struct A {
  operator T&amp;();  // #1
  operator T&amp;&amp;(); // #2
};
typedef int Fn();
A&lt;Fn&gt; a;
Fn&amp; lf = a;       // calls #1
Fn&amp;&amp; rf = a;      // calls #2
</pre>
    —end example ] or, if not that,</li>
  <li><span class="ptag" title="16.3.3 [over.match.best]/(1.6)">(1.6)</span> F1 is not a function template specialization and F2 is a function template specialization, or, if not that,</li>
  <li><span class="ptag" title="16.3.3 [over.match.best]/(1.7)">(1.7)</span> F1 and F2 are function template specializations, and the function template for F1 is more specialized
    than the template for F2 according to the partial ordering rules described in 17.5.6.2, or, if not that,</li>
  <li><span class="ptag" title="16.3.3 [over.match.best]/(1.8)">(1.8)</span> F1 is generated from a deduction-guide (16.3.1.8) and F2 is not, or, if not that,</li>
  <li><span class="ptag" title="16.3.3 [over.match.best]/(1.9)">(1.9)</span> F1 is the copy deduction candidate (16.3.1.8) and F2 is not, or, if not that,</li>
  <li><span class="ptag" title="16.3.3 [over.match.best]/(1.10)">(1.10)</span> F1 is generated from a non-template constructor and F2 is generated from a constructor template. [Example:
<pre class="agh-prog-cpp">
template &lt;class T&gt; struct A {
  using value_type = T;
  A(value_type);    // #1
  A(const A&amp;);      // #2
  A(T, T, int);     // #3
  template&lt;class U&gt;
    A(int, T, U);   // #4
  // #5 is the copy deduction candidate, A(A)
};

A x(1, 2, 3);       // uses #3, generated from a non-template constructor

template &lt;class T&gt;
A(T) -&gt; A&lt;T&gt;;       // #6, less specialized than #5

A a(42);            // uses #6 to deduce A&lt;int&gt; and #1 to initialize
A b = a;            // uses #5 to deduce A&lt;int&gt; and #2 to initialize

template &lt;class T&gt;
A(A&lt;T&gt;) -&gt; A&lt;A&lt;T&gt;&gt;; // #7, as specialized as #5

A b2 = a;           // uses #7 to deduce A&lt;A&lt;int&gt;&gt; and #1 to initialize
</pre>
    —end example ]
  </li>
  </ul>
  <p><span class="ptag" title="16.3.3 [over.match.best]/2">2</span>
  If there is exactly one viable function that is a better function than all other viable functions, then it is the
  one selected by overload resolution; otherwise the call is ill-formed. <sup>132</sup> [Example:
  </p>
<pre class="agh-prog-cpp">
void Fcn(const int*, short);
void Fcn(int*, int);

int i;
short s = 0;

void f() {
  Fcn(&amp;i, s);     // is ambiguous because &amp;i → int* is better than &amp;i → const int*
                  // but s → short is also better than s → int

  Fcn(&amp;i, 1L);    // calls Fcn(int*, int), because &amp;i → int* is better than &amp;i → const int*
                  // and 1L → short and 1L → int are indistinguishable

  Fcn(&amp;i, 'c');   // calls Fcn(int*, int), because &amp;i → int* is better than &amp;i → const int*
                  // and c → int is better than c → short
}
</pre>
  <p>—end example ]</p>
  <p><span class="ptag" title="16.3.3 [over.match.best]/3">3</span>
  If the best viable function resolves to a function for which multiple declarations were found, and if at least
  two of these declarations — or the declarations they refer to in the case of using-declarations — specify a
  default argument that made the function viable, the program is ill-formed. [Example:
  </p>
<pre class="agh-prog-cpp">
namespace A {
  extern "C" void f(int = 5);
}
namespace B {
  extern "C" void f(int = 5);
}

using A::f;
using B::f;

void use() {
  f(3); // OK, default argument was not used for viability
  f();  // Error: found default argument twice
}
</pre>
  <p>—end example ]</p>
  <p><span class="ptag">footnote 131</span>
  If a function is a static member function, this definition means that the first argument, the implied object argument, has no
  effect in the determination of whether the function is better or worse than any other function.
  </p>
  <p><span class="ptag">footnote 132</span>
  The algorithm for selecting the best viable function is linear in the number of viable functions. Run a simple tournament
  to find a function W that is not worse than any opponent it faced. Although another function F that W did not face might be at
  least as good as W , F cannot be the best function because at some point in the tournament F encountered another function G
  such that F was not better than G . Hence, W is either the best function or there is no best function. So, make a second pass over
  the viable functions to verify that W is better than all other functions.
  </p>
</div>

<h4 id="sec16.3.3.1">16.3.3.1 Implicit conversion sequences <span class="stag">[over.best.ics]</span></h4>
<p><span class="ptag" id="sec16.3.3.1p1" title="16.3.3.1 [over.best.ics]/1">1</span>
<dfn>暗黙変換列</dfn> (implicit conversion sequence) は、
実引数を対応する仮引数の型に変換するための型変換の列である。
変換列は Clause 7 で定義される暗黙変換になる。
つまり、単一の式によるオブジェクトまたは参照の初期化 (11.6, 11.6.3) である。
</p>
<p><span class="ptag" id="sec16.3.3.1p2" title="16.3.3.1 [over.best.ics]/2">2</span>
暗黙変換列では、実引数の型・cv修飾・値分類と、
それらが仮引数の対応する性質に一致するように変換する方法のみを考慮する。
実引数の寿命・記憶域クラス・アライメント・アクセス可能性、
実引数がビットフィールドかどうか、
関数が削除されている (11.4.3) かどうかといった性質は考慮されない。
従って、或る実引数と仮引数の組に対して暗黙変換列が定義されたとしても、
その実引数から仮引数への変換が最終的な解析で不適格となる可能性は残る。
</p>
<p><span class="ptag" id="sec16.3.3.1p3" title="16.3.3.1 [over.best.ics]/3">3</span>
適格な暗黙変換列は以下の内の何れかである:
</p>
<ul>
<li><span class="ptag" id="sec16.3.3.1p3.1" title="16.3.3.1 [over.best.ics]/(3.1)">(3.1)</span> <dfn>標準変換列</dfn> (standard conversion sequence) (16.3.3.1.1) か、</li>
<li><span class="ptag" id="sec16.3.3.1p3.2" title="16.3.3.1 [over.best.ics]/(3.2)">(3.2)</span> <dfn>ユーザ定義変換列</dfn> (user-defined conversion sequence) (16.3.3.1.2) か、</li>
<li><span class="ptag" id="sec16.3.3.1p3.3" title="16.3.3.1 [over.best.ics]/(3.3)">(3.3)</span> <dfn>省略記号変換列</dfn> (ellipsis conversion sequence) (16.3.3.1.3)。</li>
</ul>
<p><span class="ptag" id="sec16.3.3.1p4" title="16.3.3.1 [over.best.ics]/4">4</span>
但し、変換先が</p>
<ul>
<li><span class="ptag" id="sec16.3.3.1p4.1" title="16.3.3.1 [over.best.ics]/(4.1)">(4.1)</span> コンストラクタの最初の仮引数か、</li>
<li><span class="ptag" id="sec16.3.3.1p4.2" title="16.3.3.1 [over.best.ics]/(4.2)">(4.2)</span> ユーザ定義の変換関数の暗黙オブジェクト仮引数</li>
</ul>
<p>であり、そのコンストラクタまたはユーザ定義の変換関数が</p>
<ul>
<li><span class="ptag" id="sec16.3.3.1p4.3" title="16.3.3.1 [over.best.ics]/(4.3)">(4.3)</span>
  16.3.1.3 による候補でありかつ実引数がクラスのコピー初期化の第2ステップ(■check)による一時オブジェクトであるか、</li>
<li><span class="ptag" id="sec16.3.3.1p4.4" title="16.3.3.1 [over.best.ics]/(4.4)">(4.4)</span>
  16.3.1.4, 16.3.1.5, 16.3.1.6 による候補か、</li>
<li><span class="ptag" id="sec16.3.3.1p4.5" title="16.3.3.1 [over.best.ics]/(4.5)">(4.5)</span>
  16.3.1.7 の第2フェーズ(■check)による候補であり、
  初期化リストがただ一つのそれ自体が初期化リストである要素を持ち、
  変換先がクラス <code class="agh-prog-cpp">X</code> のコンストラクタの第一仮引数であり、
  その型が <code class="agh-prog-cpp">X</code> または "<i>cv</i> <code class="agh-prog-cpp">X</code> の参照"
  </li>
</ul>
<p>であるとき、ユーザ定義の変換列は考慮されない。
[註: ここにある規則は多重定義解決において複数のユーザ定義変換が起こること、
乃至は無限再帰を防ぐためにある。 - 註終わり ]
[例:
</p>
<pre class="agh-prog-cpp">
struct Y { Y(int); };
struct A { operator int(); };
Y y1 = A();   // error: A::operator int() は候補ではない。

struct X { };
struct B { operator X(); };
B b;
X x({b});     // error: B::operator X() は候補ではない。
</pre>
<p class="translation-note">2つ目の例は 16.3.3.1/(4.5) の例なのだと思われるが、
X x({b}) は {{b}} という初期化リストと解釈されるということなのか。■</p>
<p>- 例終わり ]</p>
<p><span class="ptag" id="sec16.3.3.1p5" title="16.3.3.1 [over.best.ics]/5">5</span>
仮引数の型が参照のときは 16.3.3.1.4 を見よ。
</p>
<p><span class="ptag" id="sec16.3.3.1p6" title="16.3.3.1 [over.best.ics]/6">6</span>
仮引数の型が参照でないとき、暗黙変換列は実引数の式による仮引数のコピー初期化をモデル化する。
暗黙変換列は、特に、実引数の式を仮引数の型の prvalue に変換するのに必要なコピー初期化である。
[註: 仮引数がクラス型の場合、これはこの章 Clause 16 のために定義される概念上の変換である。
実際の初期化はコンストラクタによって定義され、これは変換ではない。- 註終わり ]
一番外側の cv 修飾の違いは最終的な初期化で考慮されるので変換列には寄与しない。
[例: 型 <code class="agh-prog-cpp">A</code> の仮引数は <code class="agh-prog-cpp">const A</code> の実引数で初期化できる。
このとき暗黙変換列は恒等変換であり、<code class="agh-prog-cpp">const A</code> から
<code class="agh-prog-cpp">A</code> への変換は含まない。 - 例終わり ]
仮引数がクラス型を持ち実引数の式が同じ型を持つとき、暗黙変換列は恒等変換である。
仮引数がクラス型を持ち実引数の式が派生クラスの型を持つとき、
暗黙変換列は、派生クラスから基底クラスへの derived-to-base Conversion である。
[註: そのような標準返還はない。derived-to-base Conversion は暗黙変換列を記述するためだけに存在する。 - 註終わり ]
derived-to-base Conversion は Conversion ランクを持つ (16.3.3.1.1)。
</p>
<p><span class="ptag" id="sec16.3.3.1p7" title="16.3.3.1 [over.best.ics]/7">7</span>
全ての文脈で、暗黙オブジェクト仮引数または代入操作の左辺に変換するとき、標準変換のみが許される。
</p>
<p><span class="ptag" id="sec16.3.3.1p8" title="16.3.3.1 [over.best.ics]/8">8</span>
実引数を仮引数の型に一致させるのに変換が必要ない場合、
暗黙変換列は恒等変換 (16.3.3.1.1) からなる標準変換列である。
</p>
<p><span class="ptag" id="sec16.3.3.1p9" title="16.3.3.1 [over.best.ics]/9">9</span>
実引数を仮引数の型に一致させる変換の列が存在しないとき、暗黙変換列は構築できない。
</p>
<p><span class="ptag" id="sec16.3.3.1p10" title="16.3.3.1 [over.best.ics]/10">10</span>
実引数を仮引数の型に変換する変換の列として異なる複数のものが考えられるとき、
その仮引数の暗黙変換列は<span class="tcomment">それらの列を総称する</span>単一の変換列として定義し、
<dfn>曖昧な変換列</dfn> (ambiguous conversion sequence) と呼ぶ。
16.3.3.2 での暗黙変換列のランク付けにおいて、
曖昧な変換列はユーザ定義の変換列として扱われ、
他のユーザ定義変換列と比較不能とする。
[註: この規則は、仮引数の曖昧な変換列により、
関数が呼び出し可能でなくなるのを防ぐためにある。[例:
</p>
<pre class="agh-prog-cpp">
class B;
class A { A (B&amp;);};
class B { operator A (); };
class C { C (B&amp;); };
void f(A) { }
void f(C) { }
B b;
f(b);         // 不適格: コンストラクタを通した変換 b → C と、
              // コンストラクタまたは変換関数を通した曖昧な変換 b → A があるので曖昧
void f(B) { }
f(b);         // OK, 曖昧さはない
</pre>
<p>- 例終わり ]  - 註終わり ] 曖昧な変換列を持つ関数が最適な呼び出し可能関数に選ばれた場合、
対応する実引数の変換が曖昧になるのでその関数呼び出しは不適格となる。
</p>
<p><span class="ptag" id="sec16.3.3.1p11" title="16.3.3.1 [over.best.ics]/11">11</span>
既に述べた暗黙変換列の3つの形式は続く節で定義される。
</p>

<div class="en">
  <p><span class="ptag" title="16.3.3.1 [over.best.ics]/1">1</span>
  An implicit conversion sequence is a sequence of conversions used to convert an argument in a function call
  to the type of the corresponding parameter of the function being called. The sequence of conversions is an
  implicit conversion as defined in Clause 7, which means it is governed by the rules for initialization of an
  object or reference by a single expression (11.6, 11.6.3).
  </p>
  <p><span class="ptag" title="16.3.3.2 [over.best.ics]/2">2</span>
  Implicit conversion sequences are concerned only with the type, cv-qualification, and value category of the
  argument and how these are converted to match the corresponding properties of the parameter. Other
  properties, such as the lifetime, storage class, alignment, accessibility of the argument, whether the argument
  is a bit-field, and whether a function is deleted (11.4.3), are ignored. So, although an implicit conversion
  sequence can be defined for a given argument-parameter pair, the conversion from the argument to the
  parameter might still be ill-formed in the final analysis.
  </p>
  <p><span class="ptag" title="16.3.3.1 [over.best.ics]/3">3</span>
  A well-formed implicit conversion sequence is one of the following forms:
  </p>
  <ul>
  <li><span class="ptag" title="16.3.3.1 [over.best.ics]/(3.1)">(3.1)</span> a standard conversion sequence (16.3.3.1.1),</li>
  <li><span class="ptag" title="16.3.3.1 [over.best.ics]/(3.2)">(3.2)</span> a user-defined conversion sequence (16.3.3.1.2), or</li>
  <li><span class="ptag" title="16.3.3.1 [over.best.ics]/(3.3)">(3.3)</span> an ellipsis conversion sequence (16.3.3.1.3).</li>
  </ul>
  <p><span class="ptag" title="16.3.3.1 [over.best.ics]/4">4</span> However, if the target is</p>
  <ul>
  <li><span class="ptag" title="16.3.3.1 [over.best.ics]/(4.1)">(4.1)</span> the first parameter of a constructor or</li>
  <li><span class="ptag" title="16.3.3.1 [over.best.ics]/(4.2)">(4.2)</span> the implicit object parameter of a user-defined conversion function</li>
  </ul>
  <p>and the constructor or user-defined conversion function is a candidate by</p>
  <ul>
  <li><span class="ptag" title="16.3.3.1 [over.best.ics]/(4.3)">(4.3)</span> 16.3.1.3, when the argument is the temporary in the second step of a class copy-initialization,</li>
  <li><span class="ptag" title="16.3.3.1 [over.best.ics]/(4.4)">(4.4)</span>16.3.1.4, 16.3.1.5, or 16.3.1.6 (in all cases), or</li>
  <li><span class="ptag" title="16.3.3.1 [over.best.ics]/(4.5)">(4.5)</span>the second phase of 16.3.1.7 when the initializer list has exactly one element that is itself an initializer
  list, and the target is the first parameter of a constructor of class X , and the conversion is to X or
  reference to cv X,</li>
  </ul>
  <p>user-defined conversion sequences are not considered. [Note: These rules prevent more than one user-defined
  conversion from being applied during overload resolution, thereby avoiding infinite recursion. —end note ]
  [Example:
  </p>
<pre class="agh-prog-cpp">struct Y { Y(int); };
struct A { operator int(); };
Y y1 = A();   // error: A::operator int() is not a candidate

struct X { };
struct B { operator X(); };
B b;
X x({b});     // error: B::operator X() is not a candidate
</pre>
  <p>—end example ]</p>
  <p><span class="ptag" title="16.3.3.1 [over.best.ics]/5">5</span> For the case where the parameter type is a reference, see 16.3.3.1.4.</p>
  <p><span class="ptag" title="16.3.3.1 [over.best.ics]/6">6</span>
  When the parameter type is not a reference, the implicit conversion sequence models a copy-initialization of
  the parameter from the argument expression. The implicit conversion sequence is the one required to convert
  the argument expression to a prvalue of the type of the parameter. [Note: When the parameter has a class
  type, this is a conceptual conversion defined for the purposes of Clause 16; the actual initialization is defined
  in terms of constructors and is not a conversion. —end note ] Any difference in top-level cv-qualification is
  subsumed by the initialization itself and does not constitute a conversion. [Example: A parameter of type A
  can be initialized from an argument of type const A . The implicit conversion sequence for that case is the
  identity sequence; it contains no “conversion” from const A to A . —end example ] When the parameter has
  a class type and the argument expression has the same type, the implicit conversion sequence is an identity
  conversion. When the parameter has a class type and the argument expression has a derived class type,
  the implicit conversion sequence is a derived-to-base Conversion from the derived class to the base class.
  [Note: There is no such standard conversion; this derived-to-base Conversion exists only in the description of
  implicit conversion sequences. —end note ] A derived-to-base Conversion has Conversion rank (16.3.3.1.1).
  </p>
  <p><span class="ptag" title="16.3.3.1 [over.best.ics]/7">7</span>
  In all contexts, when converting to the implicit object parameter or when converting to the left operand of
  an assignment operation only standard conversion sequences are allowed.
  </p>
  <p><span class="ptag" title="16.3.3.1 [over.best.ics]/8">8</span>
  If no conversions are required to match an argument to a parameter type, the implicit conversion sequence is
  the standard conversion sequence consisting of the identity conversion (16.3.3.1.1).
  </p>
  <p><span class="ptag" title="16.3.3.1 [over.best.ics]/9">9</span>
  If no sequence of conversions can be found to convert an argument to a parameter type, an implicit conversion
  sequence cannot be formed.
  </p>
  <p><span class="ptag" title="16.3.3.1 [over.best.ics]/10">10</span>
  If several different sequences of conversions exist that each convert the argument to the parameter type, the
  implicit conversion sequence associated with the parameter is defined to be the unique conversion sequence
  designated the ambiguous conversion sequence. For the purpose of ranking implicit conversion sequences as
  described in 16.3.3.2, the ambiguous conversion sequence is treated as a user-defined conversion sequence
  that is indistinguishable from any other user-defined conversion sequence. [Note: This rule prevents a
  function from becoming non-viable because of an ambiguous conversion sequence for one of its parameters.
  [Example:
  </p>
<pre class="agh-prog-cpp">
[Example:
class B;
class A { A (B&amp;);};
class B { operator A (); };
class C { C (B&amp;); };
void f(A) { }
void f(C) { }
B b;
f(b);         // ill-formed: ambiguous because there is a conversion b → C (via constructor)
              // and an (ambiguous) conversion b → A (via constructor or conversion function)
void f(B) { }
f(b);         // OK, unambiguous
</pre>
  <p>—end example ] —end note ] If a function that uses the ambiguous conversion sequence is selected as the
  best viable function, the call will be ill-formed because the conversion of one of the arguments in the call is
  ambiguous.
  </p>
  <p><span class="ptag" title="16.3.3.1 [over.best.ics]/11">11</span>
  The three forms of implicit conversion sequences mentioned above are defined in the following subclauses.
  </p>
</div>


<h5 id="sec16.3.3.1.1">16.3.3.1.1 Standard conversion sequences <span class="stag">[over.ics.scs]</span></h5>
<h5 id="sec16.3.3.1.2">16.3.3.1.2 User-defined conversion sequences <span class="stag">[over.ics.user]</span></h5>
<h5 id="sec16.3.3.1.3">16.3.3.1.3 Ellipsis conversion sequences <span class="stag">[over.ics.ellipsis]</span></h5>
<h5 id="sec16.3.3.1.4">16.3.3.1.4 Reference binding <span class="stag">[over.ics.ref]</span></h5>
<h5 id="sec16.3.3.1.5">16.3.3.1.5 List-initialization sequence <span class="stag">[over.ics.list]</span></h5>

<h4 id="sec16.3.3.2" title="16.3.3.2 [over.ics.rank]">16.3.3.2 Ranking implicit conversion sequences <span class="stag">[over.ics.rank]</span></h4>
<p><span class="ptag" id="sec16.3.3.2p1" title="16.3.3.2 [over.ics.rank]/1">1</span>
この章では <dfn>より良い変換列</dfn> (better conversion sequence) と
<dfn>より良い変換</dfn> (better conversion) に基いて暗黙変換列に半順序を定義する。
暗黙変換列 <code>S1</code> が <code>S2</code> より良い変換列である場合、
<code>S2</code> は <code>S1</code> と比べて<dfn>より悪い変換列</dfn> (worse conversion sequence) であるという。
変換列 <code>S1</code> が <code>S2</code> に対してより良い変換列でもより悪い変換列でもないとき、
<code>S1</code> と <code>S2</code> は<dfn>比較不能変換列</dfn> (indistinguishable conversion sequences) であるという。
</p>
<p class="translation-note">indistinguishable は通常「区別できない」と訳すが、
実際の意味にそぐわないように思われるので、半順序の用語としての「比較不能」を用いることにした。
</p>
<p><span class="ptag" id="sec16.3.3.2p2" title="16.3.3.2 [over.ics.rank]/2">2</span>
暗黙変換列の基本形 (16.3.3.1) を比較するとき、
</p>
<ul>
<li><span class="ptag" id="sec16.3.3.2p2.1" title="16.3.3.2 [over.ics.rank]/(2.1)">(2.1)</span>
  標準変換列 (16.3.3.1.1) はユーザ定義変換列、省略記号変換列よりも良い変換列であり、</li>
<li><span class="ptag" id="sec16.3.3.2p2.2" title="16.3.3.2 [over.ics.rank]/(2.2)">(2.2)</span>
  ユーザ定義変換列 (16.3.3.1.2) は省略記号変換列 (16.3.3.1.3) よりも良い変換列である。</li>
</ul>
<p><span class="ptag" id="sec16.3.3.2p3" title="16.3.3.2 [over.ics.rank]/3">3</span>
同じ形の2つの暗黙変換列は、以下の規則が適用されなければ比較不能変換列である。
</p>
<ul>
<li><span class="ptag" id="sec16.3.3.2p3.1" title="16.3.3.2 [over.ics.rank]/(3.1)">(3.1)</span>
  以下のとき (この段落の他の規則が仮に適用可能だったとしても)、
  リスト初期化列 <code>L1</code> はリスト初期化列 <code>L2</code> より良い変換列である:
  <ul>
  <li><span class="ptag" id="sec16.3.3.2p3.1.1" title="16.3.3.2 [over.ics.rank]/(3.1.1)">(3.1.1)</span>
    <code>L1</code> について或る <code class="agh-prog-cpp">X</code> が存在して
    <code class="agh-prog-cpp">std::initializer_list&lt;X&gt;</code> への変換列であって、
    <code>L2</code> がそうでないときか、そうでなければ</li>
  <li><span class="ptag" id="sec16.3.3.2p3.1.2" title="16.3.3.2 [over.ics.rank]/(3.1.2)">(3.1.2)</span>
    <code>L1</code> が <code class="agh-prog-cpp">N1</code> 個の <code class="agh-prog-cpp">T</code> の配列への変換列で、
    <code>L2</code> が <code class="agh-prog-cpp">N2</code> 個の <code class="agh-prog-cpp">T</code> の配列への変換列であって、
    <code class="agh-prog-cpp">N1</code> が <code class="agh-prog-cpp">N2</code> よりも小さいとき。
    </li>
  </ul>
  [例:
<pre class="agh-prog-cpp">
void f1(int);                                 // #1
void f1(std::initializer_list&lt;long>);         // #2
void g1() { f1({42}); }                       // #2 が選ばれる

void f2(std::pair&lt;const char*, const char*>); // #3
void f2(std::initializer_list&lt;std::string>);  // #4
void g2() { f2({"foo","bar"}); }              // #4 が選ばれる
</pre>
  - 例終わり ]
  <p class="translation-note">
    「この段落の他の規則が仮に適用可能だったとしても (原文 even if one of the other rules in this paragraph would otherwise apply)」
    が何を言いたいのか良くわからない。</p>
</li>
<li><span class="ptag" id="sec16.3.3.2p3.2" title="16.3.3.2 [over.ics.rank]/(3.2)">(3.2)</span>
  以下のとき、標準変換列 <code>S1</code> は標準変換列 <code>S2</code> より良い変換列である。
  <ul>
  <li><span class="ptag" id="sec16.3.3.2p3.2.1" title="16.3.3.2 [over.ics.rank]/(3.2.1)">(3.2.1)</span>
    <code>S1</code> は <code>S2</code> の真部分列である
    (16.3.3.1.1 で定義される正準形で比較する。但し Lvalue Transformation はしない。
    恒等変換列は任意の非恒等な変換列の部分列と考える) か、そうでなければ、</li>
  <li><span class="ptag" id="sec16.3.3.2p3.2.2" title="16.3.3.2 [over.ics.rank]/(3.2.2)">(3.2.2)</span>
    <code>S1</code> のランクが <code>S2</code> のランクより良いか、
    <code>S1</code> と <code>S2</code> のランクが同じで次の段落の規則によって比較可能の場合か、
    そうでなければ、</li>
  <li><span class="ptag" id="sec16.3.3.2p3.2.3" title="16.3.3.2 [over.ics.rank]/(3.2.3)">(3.2.3)</span>
    <code>S1</code> と <code>S2</code> が参照束縛 (11.6.3) であり、
    どちらも ref-qualifier のない非静的メンバ関数の暗黙オブジェクト仮引数ではなく、
    <code>S1</code> が右辺値参照を rvalue に束縛し、
    <code>S2</code> が左辺値参照を束縛する [例:
<pre class="agh-prog-cpp">
int i;
int f1();
int&amp;&amp; f2();
int g(const int&amp;);
int g(const int&amp;&amp;);
int j = g(i);     // g(const int&amp;) が呼び出される
int k = g(f1());  // g(const int&amp;&amp;) が呼び出される
int l = g(f2());  // g(const int&amp;&amp;) が呼び出される

struct A {
  A&amp; operator&lt;&lt;(int);
  void p() &amp;;
  void p() &amp;&amp;;
};
A&amp; operator&lt;&lt;(A&amp;&amp;, char);
A() &lt;&lt; 1;         // A::operator&lt;&lt;(int) が呼び出される
A() &lt;&lt; 'c';       // operator&lt;&lt;(A&amp;&amp;, char) が呼び出される
A a;
a &lt;&lt; 1;           // A::operator&lt;&lt;(int) が呼び出される
a &lt;&lt; 'c';         // A::operator&lt;&lt;(int) が呼び出される
A().p();          // A::p()&amp;&amp; が呼び出される
a.p();            // A::p()&amp; が呼び出される
</pre>
    - 例終わり ] か、そうでなければ、</li>
  <li><span class="ptag" id="sec16.3.3.2p3.2.4" title="16.3.3.2 [over.ics.rank]/(3.2.4)">(3.2.4)</span>
    <code>S1</code> and <code>S2</code> が参照束縛 (11.6.3) であり、
    <code>S1</code> が左辺値参照を関数の lvalue に束縛し
    <code>S2</code> が右辺値参照を関数の lvalue に束縛する [例:
<pre class="agh-prog-cpp">
int f(void(&amp;)());   // #1
int f(void(&amp;&amp;)());  // #2
void g();
int i1 = f(g);      // #1 が呼び出される。
</pre>
    - 例終わり ] か、そうでなければ、
    <p class="translation-note">右辺値参照は関数の lvalue に束縛できる (11.6.3/(5.2.1.1), 16.3.3.1.4/3)。</p>
  </li>
  <li><span class="ptag" id="sec16.3.3.2p3.2.5" title="16.3.3.2 [over.ics.rank]/(3.2.5)">(3.2.5)</span>
    <code>S1</code> と <code>S2</code> が修飾変換のみにおいて異なり、
    それぞれ類似の型 <code class="agh-prog-cpp">T1</code> と <code class="agh-prog-cpp">T2</code> (7.5) を生成し、
    <code class="agh-prog-cpp">T1</code> の cv 修飾が <code class="agh-prog-cpp">T2</code> の cv 修飾の真部分集合を為す [例:
<pre class="agh-prog-cpp">
int f(const volatile int *);
int f(const int *);
int i;
int j = f(&amp;i);  // f(const int*) が呼び出される
</pre>
    - 例終わり ] か、そうでなければ、
  </li>
  <li><span class="ptag" id="sec16.3.3.2p3.2.6" title="16.3.3.2 [over.ics.rank]/(3.2.6)">(3.2.6)</span>
    <code>S1</code> と <code>S2</code> が参照束縛 (11.6.3) で、
    参照の示す先が一番外側の cv 修飾を除いて同じ型であり、
    <code>S2</code> で初期化される参照の指し示す型が、
    <code>S1</code> で初期化される参照の指し示す型に比べてより cv 修飾されている。[例:
<pre class="agh-prog-cpp">
int f(const int &amp;);
int f(int &amp;);
int g(const int &amp;);
int g(int);

int i;
int j = f(i);             // f(int &amp;) が呼び出される
int k = g(i);             // 曖昧

struct X {
  void f() const;
  void f();
};
void g(const X&amp; a, X b) {
  a.f();                  // X::f() const が呼び出される
  b.f();                  // X::f() が呼び出される
}
</pre>
    - 例終わり ]
  </li>
  </ul>
</li>
<li><span class="ptag" id="sec16.3.3.2p3.3" title="16.3.3.2 [over.ics.rank]/(3.3)">(3.3)</span>
  以下のとき、ユーザ定義変換列 <code>U1</code> はもう一つのユーザ定義変換列 <code>U2</code> に比べてより良い変換列である。
  <code>U1</code> と <code>U2</code> が同じユーザ定義変換関数・コンストラクタを含むか同じクラスを集成体初期化するとき、
  <code>U1</code> に2つ目の標準変換列が <code>U2</code> の2つ目の標準変換列よりも良い。[例:
<pre class="agh-prog-cpp">
struct A {
  operator short();
} a;
int f(int);
int f(float);
int i = f(a);       // f(int) が呼び出される。short → int の方が
                    // short → float より良いため
</pre> - 例終わり ]
</li>
</ul>
<p><span class="ptag" id="sec16.3.3.2p4" title="16.3.3.2 [over.ics.rank]/4">4</span>
標準変換列はそのランクで順序付けられる。
Exact Match は Promotion より良い変換であり、
Promotion は Conversion より良い変換である。
同じランクの2つの変換列は、以下の規則が適用されない場合は比較不能である:
</p>
<ul>
<li><span class="ptag" id="sec16.3.3.2p4.1" title="16.3.3.2 [over.ics.rank]/(4.1)">(4.1)</span>
  ポインタかメンバへのポインタか <code class="agh-prog-cpp">std::nullptr_t</code> から <code class="agh-prog-cpp">bool</code> への変換に比べて、
  それ以外の変換はより良い変換である。</li>
<li><span class="ptag" id="sec16.3.3.2p4.2" title="16.3.3.2 [over.ics.rank]/(4.2)">(4.2)</span>
  基礎型の固定された列挙型について基礎型と基礎型を昇格した型が異なるとき、
  その列挙型を基礎型に昇格する変換は、
  その列挙型を基礎型の昇格後の型に昇格する変換よりも良い変換である。</li>
<li><span class="ptag" id="sec16.3.3.2p4.3" title="16.3.3.2 [over.ics.rank]/(4.3)">(4.3)</span>
  クラス <code class="agh-prog-cpp">B</code> がクラス <code class="agh-prog-cpp">A</code> から直接もしくは間接に派生するとき、
  <code class="agh-prog-cpp">B*</code> から <code class="agh-prog-cpp">A*</code> への変換と
  <code class="agh-prog-cpp">A*</code> から <code class="agh-prog-cpp">void*</code> への変換は、
  共に <code class="agh-prog-cpp">B*</code> から <code class="agh-prog-cpp">void*</code> への変換より良い。</li>
<li><span class="ptag" id="sec16.3.3.2p4.4" title="16.3.3.2 [over.ics.rank]/(4.4)">(4.4)</span>
  クラス <code class="agh-prog-cpp">B</code> がクラス <code class="agh-prog-cpp">A</code> から直接もしくは間接に派生し、
  クラス <code class="agh-prog-cpp">C</code> がクラス <code class="agh-prog-cpp">B</code> から直接もしくは間接に派生するとき、
  <ul>
  <li><span class="ptag" id="sec16.3.3.2p4.4.1" title="16.3.3.2 [over.ics.rank]/(4.4.1)">(4.4.1)</span>
    <code class="agh-prog-cpp">C*</code> から <code class="agh-prog-cpp">B*</code> への変換は
    <code class="agh-prog-cpp">C*</code> から <code class="agh-prog-cpp">A*</code> への変換より良く、[例:
<pre class="agh-prog-cpp">
struct A {};
struct B : public A {};
struct C : public B {};
C* pc;
int f(A*);
int f(B*);
int i = f(pc);        // f(B*) が呼び出される。
</pre> - 例終わり ]
  </li>
  <li><span class="ptag" id="sec16.3.3.2p4.4.2" title="16.3.3.2 [over.ics.rank]/(4.4.2)">(4.4.2)</span>
    型 <code class="agh-prog-cpp">C</code> の式を <code class="agh-prog-cpp">B</code> への参照に束縛するのは、
    型 <code class="agh-prog-cpp">C</code> の式を <code class="agh-prog-cpp">A</code> への参照に束縛するのより良く、
    <p class="translation-note">束縛の対象と束縛先が反転している気がする。16.3.3.2/(4.4.6) も同様。</p>
    </li>
  <li><span class="ptag" id="sec16.3.3.2p4.4.3" title="16.3.3.2 [over.ics.rank]/(4.4.3)">(4.4.3)</span>
    <code class="agh-prog-cpp">A::*</code> から <code class="agh-prog-cpp">B::*</code> の変換は、
    <code class="agh-prog-cpp">A::*</code> から <code class="agh-prog-cpp">C::*</code> の変換より良く、</li>
  <li><span class="ptag" id="sec16.3.3.2p4.4.4" title="16.3.3.2 [over.ics.rank]/(4.4.4)">(4.4.4)</span>
    <code class="agh-prog-cpp">C</code> から <code class="agh-prog-cpp">B</code> の変換は、
    <code class="agh-prog-cpp">C</code> から <code class="agh-prog-cpp">A</code> の変換より良く、</li>
  <li><span class="ptag" id="sec16.3.3.2p4.4.5" title="16.3.3.2 [over.ics.rank]/(4.4.5)">(4.4.5)</span>
    <code class="agh-prog-cpp">B*</code> から <code class="agh-prog-cpp">A*</code> への変換は
    <code class="agh-prog-cpp">C*</code> から <code class="agh-prog-cpp">A*</code> への変換より良く、</li>
  <li><span class="ptag" id="sec16.3.3.2p4.4.6" title="16.3.3.2 [over.ics.rank]/(4.4.6)">(4.4.6)</span>
    型 <code class="agh-prog-cpp">C</code> の式を <code class="agh-prog-cpp">B</code> への参照に束縛するのは、
    型 <code class="agh-prog-cpp">C</code> の式を <code class="agh-prog-cpp">A</code> への参照に束縛するのより良く、</li>
  <li><span class="ptag" id="sec16.3.3.2p4.4.7" title="16.3.3.2 [over.ics.rank]/(4.4.7)">(4.4.7)</span>
    <code class="agh-prog-cpp">B::*</code> から <code class="agh-prog-cpp">C::*</code> への変換は
    <code class="agh-prog-cpp">A::*</code> から <code class="agh-prog-cpp">C::*</code> への変換より良く、</li>
  <li><span class="ptag" id="sec16.3.3.2p4.4.8" title="16.3.3.2 [over.ics.rank]/(4.4.8)">(4.4.8)</span>
    <code class="agh-prog-cpp">B</code> から <code class="agh-prog-cpp">A</code> の変換は、
    <code class="agh-prog-cpp">C</code> から <code class="agh-prog-cpp">A</code> の変換より良い。</li>
  </ul>
  [註: ユーザ定義変換列の2つ目の標準変換列同士を比較するときのみに、比較する変換列の変換元が異なる (16.3.3)。
  それ以外の場合には、変換元の型は同じで変換先の型が異なる。 - 註終わり ]
</li>
</ul>

<div class="en">
  <p><span class="ptag" title="16.3.3.2 [over.ics.rank]/1">1</span>
  This subclause defines a partial ordering of implicit conversion sequences based on the relationships better
  conversion sequence and better conversion. If an implicit conversion sequence S1 is defined by these rules to
  be a better conversion sequence than S2, then it is also the case that S2 is a worse conversion sequence than
  S1. If conversion sequence S1 is neither better than nor worse than conversion sequence S2, S1 and S2 are
  said to be indistinguishable conversion sequences.
  </p>
  <p><span class="ptag" title="16.3.3.2 [over.ics.rank]/2">2</span>
  When comparing the basic forms of implicit conversion sequences (as defined in 16.3.3.1)
  </p>
  <ul>
  <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(2.1)">(2.1)</span>
    a standard conversion sequence (16.3.3.1.1) is a better conversion sequence than a user-defined conversion
    sequence or an ellipsis conversion sequence, and</li>
  <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(2.2)">(2.2)</span>
    a user-defined conversion sequence (16.3.3.1.2) is a better conversion sequence than an ellipsis conversion
    sequence (16.3.3.1.3).</li>
  </ul>
  <p><span class="ptag" title="16.3.3.2 [over.ics.rank]/3">3</span>
  Two implicit conversion sequences of the same form are indistinguishable conversion sequences unless one of
  the following rules applies:
  </p>
  <ul>
  <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(3.1)">(3.1)</span>
    List-initialization sequence L1 is a better conversion sequence than list-initialization sequence L2 if
    <ul>
    <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(3.1.1)">(3.1.1)</span>
      L1 converts to std::initializer_list&lt;X&gt; for some X and L2 does not, or, if not that,</li>
    <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(3.1.2)">(3.1.2)</span>
      L1 converts to type “array of N1 T ”, L2 converts to type “array of N2 T ”, and N1 is smaller than N2,</li>
    </ul>
    even if one of the other rules in this paragraph would otherwise apply. [Example:
<pre class="agh-prog-cpp">
void f1(int);                                 // #1
void f1(std::initializer_list&lt;long>);         // #2
void g1() { f1({42}); }                       // chooses #2

void f2(std::pair&lt;const char*, const char*>); // #3
void f2(std::initializer_list&lt;std::string>);  // #4
void g2() { f2({"foo","bar"}); }              // chooses #4
</pre>
  —end example ]
  </li>
  <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(3.2)">(3.2)</span>
    Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence S2 if
    <ul>
    <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(3.2.1)">(3.2.1)</span>
      S1 is a proper subsequence of S2 (comparing the conversion sequences in the canonical form
      defined by 16.3.3.1.1, excluding any Lvalue Transformation; the identity conversion sequence is
      considered to be a subsequence of any non-identity conversion sequence) or, if not that,</li>
    <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(3.2.2)">(3.2.2)</span>
      the rank of S1 is better than the rank of S2 , or S1 and S2 have the same rank and are distinguishable
      by the rules in the paragraph below, or, if not that,</li>
    <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(3.2.3)">(3.2.3)</span>
      S1 and S2 are reference bindings (11.6.3) and neither refers to an implicit object parameter of a
      non-static member function declared without a ref-qualifier, and S1 binds an rvalue reference to
      an rvalue and S2 binds an lvalue reference [Example:
<pre class="agh-prog-cpp">
int i;
int f1();
int&amp;&amp; f2();
int g(const int&amp;);
int g(const int&amp;&amp;);
int j = g(i); // calls g(const int&amp;)
int k = g(f1()); // calls g(const int&amp;&amp;)
int l = g(f2()); // calls g(const int&amp;&amp;)

struct A {
  A&amp; operator&lt;&lt;(int);
  void p() &amp;;
  void p() &amp;&amp;;
};
A&amp; operator&lt;&lt;(A&amp;&amp;, char);
A() &lt;&lt; 1;     // calls A::operator&lt;&lt;(int)
A() &lt;&lt; 'c';   // calls operator&lt;&lt;(A&amp;&amp;, char)
A a;
a &lt;&lt; 1;       // calls A::operator&lt;&lt;(int)
a &lt;&lt; 'c';     // calls A::operator&lt;&lt;(int)
A().p();      // calls A::p()&amp;&amp;
a.p();        // calls A::p()&amp;
</pre>
      —end example ] or, if not that,</li>
    <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(3.2.4)">(3.2.4)</span>
      S1 and S2 are reference bindings (11.6.3) and S1 binds an lvalue reference to a function lvalue and
      S2 binds an rvalue reference to a function lvalue [Example:
<pre class="agh-prog-cpp">
int f(void(&amp;)());   // #1
int f(void(&amp;&amp;)());  // #2
void g();
int i1 = f(g);      // calls #1
</pre>
      —end example ] or, if not that,
    </li>
    <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(3.2.5)">(3.2.5)</span>
      S1 and S2 differ only in their qualification conversion and yield similar types T1 and T2 (7.5),
      respectively, and the cv-qualification signature of type T1 is a proper subset of the cv-qualification
      signature of type T2 [Example:
<pre class="agh-prog-cpp">
int f(const volatile int *);
int f(const int *);
int i;
int j = f(&amp;i);  // calls f(const int*)
</pre>
      —end example ] or, if not that,
    </li>
    <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(3.2.6)">(3.2.6)</span>
      S1 and S2 are reference bindings (11.6.3), and the types to which the references refer are the same
      type except for top-level cv-qualifiers, and the type to which the reference initialized by S2 refers
      is more cv-qualified than the type to which the reference initialized by S1 refers. [Example:
<pre class="agh-prog-cpp">
int f(const int &amp;);
int f(int &amp;);
int g(const int &amp;);
int g(int);

int i;
int j = f(i);             // calls f(int &amp;)
int k = g(i);             // ambiguous

struct X {
  void f() const;
  void f();
};
void g(const X&amp; a, X b) {
  a.f();                  // calls X::f() const
  b.f();                  // calls X::f()
}
</pre>
      —end example ]
    </li>
    </ul>
  </li>
  <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(3.3)">(3.3)</span>
    User-defined conversion sequence U1 is a better conversion sequence than another user-defined conversion
    sequence U2 if they contain the same user-defined conversion function or constructor or they initialize
    the same class in an aggregate initialization and in either case the second standard conversion sequence
    of U1 is better than the second standard conversion sequence of U2. [Example:
<pre class="agh-prog-cpp">
struct A {
  operator short();
} a;
int f(int);
int f(float);
int i = f(a);       // calls f(int), because short → int is
                    // better than short → float.
</pre> —end example ]
  </li>
  </ul>
  <p><span class="ptag" title="16.3.3.2 [over.ics.rank]/4">4</span>
  Standard conversion sequences are ordered by their ranks: an Exact Match is a better conversion than a
  Promotion, which is a better conversion than a Conversion. Two conversion sequences with the same rank
  are indistinguishable unless one of the following rules applies:
  </p>
  <ul>
  <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(4.1)">(4.1)</span>
    A conversion that does not convert a pointer, a pointer to member, or std::nullptr_t to bool is
    better than one that does.</li>
  <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(4.2)">(4.2)</span>
    A conversion that promotes an enumeration whose underlying type is fixed to its underlying type is
    better than one that promotes to the promoted underlying type, if the two are different.</li>
  <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(4.3)">(4.3)</span>
    If class B is derived directly or indirectly from class A , conversion of B* to A* is better than conversion
    of B* to void*, and conversion of A* to void* is better than conversion of B* to void*.</li>
  <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(4.4)">(4.4)</span>
    If class B is derived directly or indirectly from class A and class C is derived directly or indirectly from B 
    <ul>
    <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(4.4.1)">(4.4.1)</span>
      conversion of C* to B* is better than conversion of C* to A*, [Example:
<pre class="agh-prog-cpp">
struct A {};
struct B : public A {};
struct C : public B {};
C* pc;
int f(A*);
int f(B*);
int i = f(pc);        // calls f(B*)
</pre> —end example ]
    </li>
    <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(4.4.2)">(4.4.2)</span>
      binding of an expression of type C to a reference to type B is better than binding an expression of
      type C to a reference to type A,</li>
    <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(4.4.3)">(4.4.3)</span>
      conversion of A::* to B::* is better than conversion of A::* to C::*,</li>
    <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(4.4.4)">(4.4.4)</span>
      conversion of C to B is better than conversion of C to A,</li>
    <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(4.4.5)">(4.4.5)</span>
      conversion of B* to A* is better than conversion of C* to A*,</li>
    <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(4.4.6)">(4.4.6)</span>
      binding of an expression of type B to a reference to type A is better than binding an expression of
      type C to a reference to type A,</li>
    <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(4.4.7)">(4.4.7)</span>
      conversion of B::* to C::* is better than conversion of A::* to C::*, and</li>
    <li><span class="ptag" title="16.3.3.2 [over.ics.rank]/(4.4.8)">(4.4.8)</span>
      conversion of B to A is better than conversion of C to A.</li>
    </ul>
    [Note: Compared conversion sequences will have different source types only in the context of comparing
    the second standard conversion sequence of an initialization by user-defined conversion (see 16.3.3); in
    all other contexts, the source types will be the same and the target types will be different. —end note ]
  </li>
  </ul>
</div>

<h2 id="sec16.4">16.4 Address of overloaded function [over.over]</h2>
<h2 id="sec16.5">16.5 Overloaded operators [over.oper]</h2>
<h2 id="sec16.6">16.6 Built-in operators [over.built]</h2>

<h1 id="sec17">17 Templates <span class="stag">[temp]</span></h1>
<p>略</p>
<h1 id="sec18">18 Exception handling <span class="stag">[except]</span></h1>
<p>略</p>
<h1 id="sec19">19 Preprocessing Directives <span class="stag">[cpp]</span></h1>
<p>略</p>
</body>
</html>
