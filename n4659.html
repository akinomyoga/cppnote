<!DOCTYPE html>
<html>
<head>
  <title>N4659</title>
  <meta charset="utf-8" />
  <style>
  body{max-width: 60em; margin-left: auto; margin-right: auto; text-align: justify}
  span.stag{color: blue; vertical-align: super; font-size: 80%; margin-right: 0.1em;}
  /*p.translation-note{border:1px solid gray;padding:0.5em;}*/
  p.translation-note{background-color: #ddd; padding: 0.8em;}
  p.translation-note:before{content: "訳註:"; font-weight: bold;}
  div.en{background-color: #eec; padding: 0.8em;}
  div.en:before{content: "原文"; font-weight: bold;}
  </style>
  <meta name="agh-fly-type" content="color" />
  <script src="https://akinomyoga.github.io/agh/agh.fly.js" charset="utf-8"></script>
</head>
<body>
<h1>Working Draft, Standard for Programming Language C ++</h1>
<p>略</p>

<h1>Contents</h1>
<p>略</p>

<h1>List of Tables</h1>
<p>略</p>

<h1>List of Figures</h1>
<p>略</p>

<h1>1 Scope <span class="secname">[intro.scope]</span></h1>
<p><span class="stag">1 [intro.scope]/1</span>
この文書は C++ プログラミング言語の処理系に対する要求を指定する。
第一の要求は処理系が言語を実装することであり、これはこの文書が C++ を定義するということを意味する。
その他の要求と、第一の要求の例外は、この文書の中で折に触れて述べる。
</p>
<p><span class="stag">1 [intro.scope]/2</span>
C++ は 「ISO/IEC 9899:2011 Programming languates -- C」(以降 C 規格と呼ぶ) によって定義される C 言語を元にした汎用の言語である。
C によって提供される機能の他に、C++ は追加のデータ型、クラス、テンプレート、例外、名前空間、
演算子と関数の多重定義、参照、メモリ管理の演算子、追加のライブラリ機能を提供する。
</p>
<div class="en">
  <p><span class="stag">1 [intro.scope]/1</span>
  This document specifies requirements for implementations of the C++ programming language. The first such
  requirement is that they implement the language, so this document also defines C++ . Other requirements
  and relaxations of the first requirement appear at various places within this document.
  </p>
  <p><span class="stag">1 [intro.scope]/2</span>
  C++ is a general purpose programming language based on the C programming language as described in
  ISO/IEC 9899:2011 Programming languages — C (hereinafter referred to as the C standard). In addition to
  the facilities provided by C, C ++ provides additional data types, classes, templates, exceptions, namespaces,
  operator overloading, function name overloading, references, free store management operators, and additional
  library facilities.</p>
</div>
<p class="translation-note">
この部分は C++03 の時から更新されていない。
C++11 以降で追加されたメジャーな機能――例えばラムダ式などは追加しなくても良いのだろうか?
</p>

<h1>2 Normative references <span class="secname">[intro.refs]</span></h1>
<p><span class="stag">2 [intro.refs]/1</span>
The following documents are referred to in the text in such a way that some or all of their content constitutes
requirements of this document. For dated references, only the edition cited applies. For undated references,
the latest edition of the referenced document (including any amendments) applies.
</p>
<ul>
<li><span class="stag">2 [intro.refs]/1(1.*)</span> 略</li>
</ul>
<p>以下の文書は、その内容の一部または全ての内容がこの文書の要求を構成するものとして、この文書の本文から適宜参照される。
以下の文書で版が指定されている場合は、ここで参照した版のみが有効である。
版が指定されていない場合は、その文書の最新版 (正誤表を含む) が有効である。
</p>
<ul>
<li>略</li>
</ul>
<p><span class="stag">2 [intro.refs]/2</span> 略</p>
<p><span class="stag">2 [intro.refs]/3</span> 略</p>
<p><span class="stag">2 [intro.refs]/4</span> 略</p>
<p><span class="stag">2 [intro.refs]/5</span> 略</p>

<h1>3 Terms and definitions <span class="secname">[intro.defs]</span></h1>
<p><span class="stag">3 [intro.defs]/1</span> 略</p>
<p><span class="stag">3 [intro.defs]/2</span> 略</p>
<p><span class="stag">3 [intro.defs]/3</span> 略</p>
<p><span class="stag">3 [intro.defs]/4</span> 略</p>

<h2>3.1 access <span class="secname">[defns.access]</span></h2>
<p>〈execution-time action〉 to read or modify the value of an object</p>
<p>《実行時の動作》 オブジェクトの値を読み取るか修正すること</p>

<h2>3.2 argument <span class="secname">[defns.argument]</span></h2>
<p>〈function call expression〉 expression in the comma-separated list bounded by the parentheses (8.2.2)</p>
<p>《関数呼び出し式》 丸括弧で囲まれたカンマ区切りのリストに含まれる式 (8.2.2)</p>

<h2>3.3 argument <span class="secname">[defns.argument.macro]</span></h2>
<p>〈function-like macro〉 sequence of preprocessing tokens in the comma-separated list bounded by the parentheses (19.3)</p>

<h2>3.4 argument <span class="secname">[defns.argument.throw]</span></h2>
<p>〈throw expression〉 the operand of <code>throw</code> (8.17)</p>
<p>《例外スロー式》 <code>throw</code> の対象 (8.17)</p>

<h2>3.5 argument <span class="secname">[defns.argument.templ]</span></h2>
<p>〈template instantiation〉 <i>constant-expression</i>, <i>type-id</i>, or <i>id-expression</i> in the comma-separated list bounded by the angle brackets (17.3)</p>
<p>《テンプレート実体化》 角括弧で囲まれたカンマ区切りのリストに含まれる <i>定数式</i>、<i>type-id</i>、または <i>id-expression</i> (17.3)</p>

<h2>3.* 略</h2>

<h1>4 略</h1>
<h1>5 略</h1>
<h1>6 略</h1>
<h1>7 略</h1>
<h1>8 略</h1>
<h1>9 略</h1>
<h1>10 略</h1>
<h1>11 略</h1>
<h1>12 略</h1>
<h1>13 略</h1>
<h1>14 略</h1>
<h1>15 略</h1>
<h1>16 Overloading <span class="secname">[over]</span></h1>
<p><span class="stag">16 [over]/1</span> 同じスコープで一つの名前について2つ以上の宣言が指定された時、その名前は多重定義 (overload) されているという。
更に、同じスコープで同じ名前だが異なる型の二つの宣言を多重定義 (overloaded declaration) と呼ぶ。
関数および関数テンプレートの宣言のみが多重定義されうる。
つまり、変数と型の宣言は多重定義できない。
</p>
<p><span class="stag">16 [over]/2</span> 多重定義された関数名が呼び出しで使われた時、
関数の多重定義の内どれが用いられるかは、
実引数の型とその時点で見えている (visible) 多重定義の仮引数の型を比較することによって決定される。
関数を選択する手続きは多重定義解決と呼び 16.3 で定義される。[ 例ここから: 
</p>
<pre class="agh-prog-cpp">
double abs(double);
int abs(int);

abs(1); // abs(int); が呼び出される
abs(1.0); // abs(double); が呼び出される
</pre>
<p>-- 例ここまで ]</p>
<div class="en">
  <p><span class="stag">16 [over]/1</span>
  When two or more different declarations are specified for a single name in the same scope, that name is said
  to be overloaded. By extension, two declarations in the same scope that declare the same name but with
  different types are called overloaded declarations. Only function and function template declarations can be
  overloaded; variable and type declarations cannot be overloaded.
  </p>
  <p><span class="stag">16 [over]/2</span>
  When an overloaded function name is used in a call, which overloaded function declaration is being referenced
  is determined by comparing the types of the arguments at the point of use with the types of the parameters
  in the overloaded declarations that are visible at the point of use. This function selection process is called
  overload resolution and is defined in 16.3. [Example:
  </p>
  <pre class="agh-prog-cpp">
double abs(double);
int abs(int);

abs(1); // calls abs(int);
abs(1.0); // calls abs(double);
</pre>
  <p>-- end example]</p>
</div>

<h2>16.1 Overloadable declarations <span class="secname">[over.load]</span></h2>
<p><span class="stag">16.1 [over.load]/1</span>
全ての関数宣言が多重定義出来るわけではない。
多重定義できないものをここで指定する。
同じスコープに多重定義できない宣言の組を含むプログラムは不適格である。
[註: この制限は、そのスコープにおける明示的宣言同士、または明示宣言と using 宣言により導入される宣言の間に適用される。
(using 指令などに基づく) 名前解決や、 (演算子関数などの) 多重定義解決の過程で考慮される関数の集合に対しては適用されない。 - 註終わり ]
</p>
<p><span class="stag">16.1 [over.load]/2</span> 一部の関数宣言は多重定義できない:</p>
<ul>
<li><span class="stag">16.1 [over.load]/2(2.1)</span>
  戻り値の型、例外指定子 (18.4) を除いて一致する関数宣言は多重定義できない。</li>
<li><span class="stag">16.1 [over.load]/2(2.2)</span>
  同名で同じ仮引数リスト (11.3.5) を持つメンバ関数宣言は、
  その内の一つが静的メンバ関数宣言 (12.2.3) であるとき、多重定義できない。
  同様日、同名で同じ仮引数リスト、同じテンプレート仮引数リストを持つメンバ関数テンプレート宣言は、
  その内の一つが静的メンバ関数テンプレート宣言であるとき、多重定義できない。
  この規則で仮引数リストを比較する際、多重定義解決のために導入される暗黙オブジェクト仮引数 (16.3.1) の型は考慮されない。
  一方で、静的メンバ関数宣言が含まれない場合は、暗黙オブジェクト仮引数が異なる関数宣言を多重定義できる。
  [ 例: この違いを以下のコードに示す:
  <pre class="agh-prog-cpp">
class X {
  static void f();
  void f();                 // 不適格
  void f() const;           // 不適格
  void f() const volatile;  // 不適格
  void g();
  void g() const;           // OK: 静的な g がないので
  void g() const volatile;  // OK: 静的な g がないので
};
</pre>
  - 例終わり ]
  </li>
<li><span class="stag">16.1 [over.load]/2(2.3)</span>
  同名・同じ仮引数リストを持つメンバ関数宣言と、
  同名・同じ仮引数リスト・同じテンプレート仮引数リストを持つメンバ関数テンプレートは、
  その内 1 つでも ref 修飾子を持っている場合、
  全てが ref 修飾子を持っていなければ多重定義できない。
  [ 例:
  <pre class="agh-prog-cpp">
class Y {
  void h() &;
  void h() const &; // OK
  void h() &&;      // OK, 全ての宣言が ref 修飾子を持つ。
  void i() &;
  void i() const;   // 不適格。前の i の宣言は ref 修飾子を持つ。
};
  </pre>
  - 例終わり ]
  </li>
</ul>

<div class="en">
  <p><span class="stag">16.1 [over.load]/1</span>
  Not all function declarations can be overloaded. Those that cannot be overloaded are specified here. A
  program is ill-formed if it contains two such non-overloadable declarations in the same scope. [Note: This
  restriction applies to explicit declarations in a scope, and between such declarations and declarations made
  through a using-declaration (10.3.3). It does not apply to sets of functions fabricated as a result of name
  lookup (e.g., because of using-directives) or overload resolution (e.g., for operator functions). - end note ]
  </p>
  <p><span class="stag">16.1 [over.load]/2</span>
  Certain function declarations cannot be overloaded:
  </p>
  <ul>
  <li><span class="stag">16.1 [over.load]/2(2.1)</span>
    Function declarations that differ only in the return type, the exception specification (18.4), or both
    cannot be overloaded.</li>
  <li><span class="stag">16.1 [over.load]/2(2.2)</span>
    Member function declarations with the same name and the same parameter-type-list (11.3.5) cannot be
    overloaded if any of them is a static member function declaration (12.2.3). Likewise, member function
    template declarations with the same name, the same parameter-type-list, and the same template
    parameter lists cannot be overloaded if any of them is a static member function template declaration.
    The types of the implicit object parameters constructed for the member functions for the purpose of
    overload resolution (16.3.1) are not considered when comparing parameter-type-lists for enforcement
    of this rule. In contrast, if there is no static member function declaration among a set of member
    function declarations with the same name and the same parameter-type-list, then these member function
    declarations can be overloaded if they differ in the type of their implicit object parameter. [Example:
    The following illustrates this distinction:
    <pre class="agh-prog-cpp">
class X {
  static void f();
  void f();                 // ill-formed
  void f() const;           // ill-formed
  void f() const volatile;  // ill-formed
  void g();
  void g() const;           // OK: no static g
  void g() const volatile;  // OK: no static g
};
</pre>
    —end example ]
    </li>
  <li><span class="stag">16.1 [over.load]/2(2.3)</span> Member function declarations with the same name and the same parameter-type-list (11.3.5) as well as
    member function template declarations with the same name, the same parameter-type-list, and the same
    template parameter lists cannot be overloaded if any of them, but not all, have a ref-qualifier (11.3.5).
    [Example:
    <pre class="agh-prog-cpp">
class Y {
  void h() &;
  void h() const &; // OK
  void h() &&;      // OK, all declarations have a ref-qualifier
  void i() &;
  void i() const;   // ill-formed, prior declaration of i
                    // has a ref-qualifier
};
</pre>
    —end example ]
    </li>
  </ul>
</div>

<p><span class="stag">16.1 [over.load]/3</span>
[註: 11.3.5 で指定したように、関数宣言の組が等価な仮引数宣言を持つ場合、
これらは同じ関数を宣言することになるので多重定義することはできない。
</p>
<ul>
<li><span class="stag">16.1 [over.load]/3(3.1)</span> 等価な typedef された型を使っている点だけ異なる仮引数宣言は等価である。
typedef は独立した方ではなく、ただ他の型の別名を与えるに過ぎない (10.1.3)。[例:
  <pre class="agh-prog-cpp">
typedef int Int;
void f(int i);
void f(Int i);              // OK: f(int) の再宣言
void f(int i) { /* ... */ }
void f(Int i) { /* ... */ } // error: f(int) の再定義
</pre>
  - 例終わり ]
  一方で列挙型は独立した型であり、関数の異なる多重定義を与える。
  [例:
  <pre class="agh-prog-cpp">
enum E { a };
void f(int i) { /* ... */ }
void f(E i) { /* ... */ }
</pre>
  - 例終わり ]
  </li>
<li><span class="stag">16.1 [over.load]/3(3.2)</span>
一方がポインタ * であり他方が配列 [] であるという点のみ異なる仮引数宣言は等価である。
即ち、配列宣言はポインタ宣言に調整 (11.3.5) されるためである。
2番目以降の配列の次元のみが仮引数の型において意味を持つ (11.3.4)。[例:
  <pre class="agh-prog-cpp">
int f(char*);
int f(char[]);      // f(char*); と同じ
int f(char[7]);     // f(char*); と同じ
int f(char[9]);     // f(char*); と同じ
int g(char(*)[10]);
int g(char[5][10]); // g(char(*)[10]); と同じ
int g(char[7][10]); // g(char(*)[10]); と同じ
int g(char(*)[20]); // g(char(*)[10]); とは異なる。
</pre>
  - 例終わり ]
  </li>
<li><span class="stag">16.1 [over.load]/3(3.3)</span>
一方が関数型であり他方が同じ関数型へのポインタであるという点のみ異なる仮引数宣言は等価である。
即ち、関数型は関数型へのポインタへと調整 (11.3.5) されるためである。[例:
  <pre class="agh-prog-cpp">
void h(int());
void h(int (*)());      // h(int()) の再宣言
void h(int x()) { }     // h(int()) の定義
void h(int (*x)()) { }  // 不適格: h(int()) の再定義
</pre>
  - 例終わり ]
  </li>
<li><span class="stag">16.1 [over.load]/3(3.4)</span>
cosnt または volatile が存在するかどうかのみが異なる仮引数宣言は等価である。
即ち、どの関数型が宣言されるか・定義されるか・呼び出されるかを決定する際に、
仮引数型の const/volatile 型指定子は無視される。[例:
  <pre class="agh-prog-cpp">
typedef const int cInt;
int f (int);
int f (const int);          // f(int) の再宣言
int f (int) { /* ... */ }   // f(int) の定義
int f (cInt) { /* ... */ }  // error: f(int) の再定義
</pre>
  - 例終わり ]
  仮引数型の一番外側の const/volatile 型指定子のみが、以下のように無視される。
  仮引数型の内部に埋め込まれた const/volatile 型指定子は、
  関数の多重定義を区別する上で意味を持つ<sup>123</sup>。
  特に、任意の型 <code>T</code> について、<code>T</code> へのポインタ、
  <code>const T</code> へのポインタ、<code>volatile T</code> へのポインタは、
  異なる仮引数型と解釈される。
  <code>T</code> への参照、<code>const T</code> への参照、
  <code>volatile T</code> への参照についても同様である。
  </li>
<li><span class="stag">16.1 [over.load]/3(3.5)</span> 既定の実引数のみが相違する仮引数宣言は等価である。[例:
  以下の例を考慮されたい:
  <pre class="agh-prog-cpp">
void f (int i, int j);
void f (int i, int j = 99); // OK: f(int, int) の再宣言
void f (int i = 88, int j); // OK: f(int, int) の再宣言
void f ();                  // OK: f の多重定義の宣言
void prog () {
  f (1, 2);                 // OK: f(int, int) の呼び出し
  f (1);                    // OK: f(int, int) の呼び出し
  f ();                     // Error: f(int, int) と f() のどちら?
}
</pre>
  - 例終わり ]
  </li>
</ul>
<p>- 註終わり ]</p>
<p><span class="stag">footnote 123</span>
仮引数型が関数型を含む場合 (例えば仮引数型が関数ポインタの場合)、
その内部関数型の仮引数型において最も外側の const/volatile 型指定子は無視される。</p>
<p class="translation-note">
この部分は Note に過ぎないので細かいことは気にしていないのかもしれないが、色々と記述に穴がある気がする。
例えば、differs only として項目を連ねているが、2つ以上の項目で異なる場合については述べていないので語弊がある。
また、内部関数型の仮引数の const/volatile 無視については述べているが typedef/配列型/関数型 については述べていない。
実際のコンパイラで試すと、期待通り typedef/配列型/関数型 も考慮に入れられるようなので、これはここの記述が分かりにくいだけだ。
思うに、〈仮引数の宣言型〉・〈仮引数の調整型〉・〈型の同一性〉のような概念を導入して統一的に定義するべきなのではという気がする。
</p>

<div class="en">
  <p><span class="stag">16.1 [over.load]/3</span> [Note: As specified in 11.3.5, function declarations that have equivalent parameter declarations declare the
  same function and therefore cannot be overloaded:
  </p>
  <ul>
  <li><span class="stag">16.1 [over.load]/3(3.1)</span> Parameter declarations that differ only in the use of equivalent typedef “types” are equivalent. A
    typedef is not a separate type, but only a synonym for another type (10.1.3). [Example:
    <pre class="agh-prog-cpp">
typedef int Int;
void f(int i);
void f(Int i);              // OK: redeclaration of f(int)
void f(int i) { /* ... */ }
void f(Int i) { /* ... */ } // error: redefinition of f(int)
</pre>
    —end example ]
    Enumerations, on the other hand, are distinct types and can be used to distinguish overloaded function
    declarations. [Example:
    <pre class="agh-prog-cpp">
enum E { a };
void f(int i) { /* ... */ }
void f(E i) { /* ... */ }
</pre>
    —end example ]
    </li>
  <li><span class="stag">16.1 [over.load]/3(3.2)</span> Parameter declarations that differ only in a pointer * versus an array [] are equivalent. That is, the
    array declaration is adjusted to become a pointer declaration (11.3.5). Only the second and subsequent
    array dimensions are significant in parameter types (11.3.4). [Example:
    <pre class="agh-prog-cpp">
int f(char*);
int f(char[]);      // same as f(char*);
int f(char[7]);     // same as f(char*);
int f(char[9]);     // same as f(char*);
int g(char(*)[10]);
int g(char[5][10]); // same as g(char(*)[10]);
int g(char[7][10]); // same as g(char(*)[10]);
int g(char(*)[20]); // different from g(char(*)[10]);
</pre>
    —end example ]
    </li>
  <li><span class="stag">16.1 [over.load]/3(3.3)</span> Parameter declarations that differ only in that one is a function type and the other is a pointer to
    the same function type are equivalent. That is, the function type is adjusted to become a pointer to
    function type (11.3.5). [Example:
    <pre class="agh-prog-cpp">
void h(int());
void h(int (*)());      // redeclaration of h(int())
void h(int x()) { }     // definition of h(int())
void h(int (*x)()) { }  // ill-formed: redefinition of h(int())
</pre>
    —end example ]
    </li>
  <li><span class="stag">16.1 [over.load]/3(3.4)</span> Parameter declarations that differ only in the presence or absence of const and/or volatile are
    equivalent. That is, the const and volatile type-specifiers for each parameter type are ignored when
    determining which function is being declared, defined, or called. [Example:
    <pre class="agh-prog-cpp">
typedef const int cInt;
int f (int);
int f (const int);          // redeclaration of f(int)
int f (int) { /* ... */ }   // definition of f(int)
int f (cInt) { /* ... */ }  // error: redefinition of f(int)
</pre>
    —end example ]
    Only the const and volatile type-specifiers at the outermost level of the parameter type specification
    are ignored in this fashion; const and volatile type-specifiers buried within a parameter type
    specification are significant and can be used to distinguish overloaded function declarations. 123 In
    particular, for any type T , “pointer to T ”, “pointer to const T ”, and “pointer to volatile T ” are
    considered distinct parameter types, as are “reference to T ”, “reference to const T ”, and “reference to
    volatile T”.
    </li>
  <li><span class="stag">16.1 [over.load]/3(3.5)</span> Two parameter declarations that differ only in their default arguments are equivalent. [Example:
    Consider the following:
    <pre class="agh-prog-cpp">
void f (int i, int j);
void f (int i, int j = 99); // OK: redeclaration of f(int, int)
void f (int i = 88, int j); // OK: redeclaration of f(int, int)
void f ();                  // OK: overloaded declaration of f
void prog () {
  f (1, 2);                 // OK: call f(int, int)
  f (1);                    // OK: call f(int, int)
  f ();                     // Error: f(int, int) or f()?
}
</pre>
    —end example ]
    </li>
  </ul>
  <p>—end note ]</p>
  <p><span class="stag">footnote 123</span> When a parameter type includes a function type, such as in the case of a parameter type that is a pointer to function, the
  const and volatile type-specifiers at the outermost level of the parameter type specifications for the inner function type are
  also ignored.</p>
</div>
</body>
</html>
