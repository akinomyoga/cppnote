<!DOCTYPE html>
<html>
<head>
  <title>N4659</title>
  <meta charset="utf-8" />
  <style>
  body{max-width: 60em; margin-left: auto; margin-right: auto; text-align: justify}
  span.stag{color: green; font-weight: bold; vertical-align: super; font-size: 80%; margin-right: 0.1em;}
  /*p.translation-note{border:1px solid gray;padding:0.5em;}*/
  .translation-note{background-color: #ddd; padding: 0.8em; margin-bottom: 0.8em;}
  .translation-note:before{content: "訳註: "; font-weight: bold;}
  div.en{background-color: #eec; padding: 0.8em;}
  div.en:before{content: "原文 "; font-weight: bold;}

  span.tcomment {color: green;}
  span.tcomment:before {content: "[訳者: ";}
  span.tcomment:after {content: "]";}

  span.ICS>i{margin-right: 0.1em;} /* イタリック補正 */
  </style>
  <meta name="agh-fly-type" content="color" />
  <script src="https://akinomyoga.github.io/agh/agh.fly.js" charset="utf-8"></script>
</head>
<body>
<h1>Working Draft, Standard for Programming Language C ++</h1>
<p>略</p>

<p class="translation-note">
この訳では、自然な日本語になるように、
規格としての意味が変わらない範囲で適宜文の構造を変えるなどしている。
例えば、長い文を2つに分ける、日本語として冗長な表現を排するなどのことをしている。
</p>
<div class="translation-note">
  訳語について
  <ul>
  <li>access rule → アクセス規則</li>
  <li>overload → 多重定義する</li>
  <li>overloaded declarations → 多重定義 (実は多重宣言の方が適切な気がするが多重定義とするのが一般的である)</li>
  <li>type-specifier → 型指定子</li>
  <li>visible → 可視の</li>
  <li>invocation, call → 呼び出し (両者は今のところ日本語では区別しない)</li>
  <li>accessibility of the function → 関数のアクセス可能性</li>
  <li>pointer-to-function → 関数ポインタ</li>
  <li>reference-to-function → 関数の参照</li>
  <li>reference-to-pointer-to-function → 関数ポインタの参照</li>
  <li>default-initialization → 既定初期化</li>
  <li>direct-initialization → 直接初期化</li>
  <li>copy-initialization → コピー初期化</li>
  <li>viable functions → 呼び出し可能関数 (JIS C++ では二次候補関数としている)</li>
  <li>implicit conversion sequence → 暗黙変換列</li>
  <li>implicit object paramter → 暗黙オブジェクト仮引数</li>
  <li>implied object argument → 暗黙オブジェクト実引数</li>
  </ul>
</div>

<h1>Contents</h1>
<p>略</p>

<h1>List of Tables</h1>
<p>略</p>

<h1>List of Figures</h1>
<p>略</p>

<h1 id="sec1">1 Scope <span class="secname">[intro.scope]</span></h1>
<p><span class="stag" id="sec1p1" title="1 [intro.scope]/1">1</span>
この文書は C++ プログラミング言語の処理系に対する要求を指定する。
第一の要求は処理系が言語を実装することであり、これはこの文書が C++ を定義するということを意味する。
その他の要求と、第一の要求の例外は、この文書の中で折に触れて述べる。
</p>
<p><span class="stag" id="sec1p2" title="1 [intro.scope]/2">2</span>
C++ は 「ISO/IEC 9899:2011 Programming languates -- C」(以降 C 規格と呼ぶ) によって定義される C 言語を元にした汎用の言語である。
C によって提供される機能の他に、C++ は追加のデータ型、クラス、テンプレート、例外、名前空間、
演算子と関数の多重定義、参照、メモリ管理の演算子、追加のライブラリ機能を提供する。
</p>
<div class="en">
  <p><span class="stag" title="1 [intro.scope]/1">1</span>
  This document specifies requirements for implementations of the C++ programming language. The first such
  requirement is that they implement the language, so this document also defines C++ . Other requirements
  and relaxations of the first requirement appear at various places within this document.
  </p>
  <p><span class="stag" title="1 [intro.scope]/2">2</span>
  C++ is a general purpose programming language based on the C programming language as described in
  ISO/IEC 9899:2011 Programming languages — C (hereinafter referred to as the C standard). In addition to
  the facilities provided by C, C ++ provides additional data types, classes, templates, exceptions, namespaces,
  operator overloading, function name overloading, references, free store management operators, and additional
  library facilities.</p>
</div>
<p class="translation-note">
この部分は C++03 の時から更新されていない。
C++11 以降で追加されたメジャーな機能――例えばラムダ式などは追加しなくても良いのだろうか?
</p>

<h1 id="sec2">2 Normative references <span class="secname">[intro.refs]</span></h1>
<p><span class="stag" id="sec2p1" title="2 [intro.refs]/2">2</span>
以下の文書は、その内容の一部または全ての内容がこの文書の要求を構成するものとして、この文書の本文から適宜参照される。
以下の文書で版が指定されている場合は、ここで参照した版のみが有効である。
版が指定されていない場合は、その文書の最新版 (訂正 (amendments) を含む) が有効である。
</p>
<ul>
<li><span class="stag" id="sec2p1.1" title="2 [intro.refs]/(1.*)">(1.*)</span> 略</li>
</ul>
<div class="en">
  <p><span class="stag" title="2 [intro.refs]/1">1</span>
  The following documents are referred to in the text in such a way that some or all of their content constitutes
  requirements of this document. For dated references, only the edition cited applies. For undated references,
  the latest edition of the referenced document (including any amendments) applies.
  </p>
  <ul>
  <li><span class="stag" title="2 [intro.refs]/(1.*)">(1.*)</span> 略</li>
  </ul>
</div>
<p><span class="stag" title="2 [intro.refs]/2">2</span> 略</p>
<p><span class="stag" title="2 [intro.refs]/3">3</span> 略</p>
<p><span class="stag" title="2 [intro.refs]/4">4</span> 略</p>
<p><span class="stag" title="2 [intro.refs]/5">5</span> 略</p>

<h1 id="sec3">3 Terms and definitions <span class="secname">[intro.defs]</span></h1>
<p><span class="stag" title="3 [intro.defs]/1">1</span> 略</p>
<p><span class="stag" title="3 [intro.defs]/2">2</span> 略</p>
<p><span class="stag" title="3 [intro.defs]/3">3</span> 略</p>
<p><span class="stag" title="3 [intro.defs]/4">4</span> 略</p>

<h2 id="sec3.1">3.1 access <span class="secname">[defns.access]</span></h2>
<p>〈execution-time action〉 to read or modify the value of an object</p>
<p>《実行時の動作》 オブジェクトの値を読み取るか修正すること</p>

<h2 id="sec3.2">3.2 argument <span class="secname">[defns.argument]</span></h2>
<p>〈function call expression〉 expression in the comma-separated list bounded by the parentheses (8.2.2)</p>
<p>《関数呼び出し式》 丸括弧で囲まれたカンマ区切りのリストに含まれる式 (8.2.2)</p>

<h2 id="sec3.3">3.3 argument <span class="secname">[defns.argument.macro]</span></h2>
<p>〈function-like macro〉 sequence of preprocessing tokens in the comma-separated list bounded by the parentheses (19.3)</p>

<h2 id="sec3.4">3.4 argument <span class="secname">[defns.argument.throw]</span></h2>
<p>〈throw expression〉 the operand of <code class="agh-prog-cpp">throw</code> (8.17)</p>
<p>《例外スロー式》 <code class="agh-prog-cpp">throw</code> の対象 (8.17)</p>

<h2 id="sec3.5">3.5 argument <span class="secname">[defns.argument.templ]</span></h2>
<p>〈template instantiation〉 <i>constant-expression</i>, <i>type-id</i>, or <i>id-expression</i> in the comma-separated list bounded by the angle brackets (17.3)</p>
<p>《テンプレート実体化》 角括弧で囲まれたカンマ区切りのリストに含まれる <i>定数式</i>、<i>type-id</i>、または <i>id-expression</i> (17.3)</p>

<h2>3.* 略</h2>

<h1>4 略</h1>
<h1>5 略</h1>
<h1>6 略</h1>
<h1>7 略</h1>
<h1>8 略</h1>
<h1>9 略</h1>
<h1>10 略</h1>
<h1>11 略</h1>
<h1>12 略</h1>
<h1>13 略</h1>
<h1>14 略</h1>
<h1>15 略</h1>
<h1 id="sec16">16 Overloading <span class="secname">[over]</span></h1>
<p><span class="stag" id="sec16p1" title="16 [over]/1">1</span> 同じスコープで一つの名前について2つ以上の宣言が指定された時、その名前は多重定義 (overload) されているという。
更に、同じスコープで同じ名前だが異なる型の二つの宣言を多重定義 (overloaded declaration) と呼ぶ。
関数および関数テンプレートの宣言のみが多重定義されうる。
つまり、変数と型の宣言は多重定義できない。
</p>
<p><span class="stag" id="sec16p2" title="16 [over]/2">2</span> 多重定義された関数名が呼び出しで使われた時、
関数の多重定義の内どれが用いられるかは、
実引数の型とその時点で可視の多重定義の仮引数の型を比較することによって決定される。
関数を選択する手続きは多重定義解決と呼び 16.3 で定義される。[ 例:
</p>
<pre class="agh-prog-cpp">
double abs(double);
int abs(int);

abs(1); // abs(int); が呼び出される
abs(1.0); // abs(double); が呼び出される
</pre>
<p>- 例終わり ]</p>
<div class="en">
  <p><span class="stag" title="16 [over]/1">1</span>
  When two or more different declarations are specified for a single name in the same scope, that name is said
  to be overloaded. By extension, two declarations in the same scope that declare the same name but with
  different types are called overloaded declarations. Only function and function template declarations can be
  overloaded; variable and type declarations cannot be overloaded.
  </p>
  <p><span class="stag" title="16 [over]/2">2</span>
  When an overloaded function name is used in a call, which overloaded function declaration is being referenced
  is determined by comparing the types of the arguments at the point of use with the types of the parameters
  in the overloaded declarations that are visible at the point of use. This function selection process is called
  overload resolution and is defined in 16.3. [Example:
  </p>
  <pre class="agh-prog-cpp">
double abs(double);
int abs(int);

abs(1); // calls abs(int);
abs(1.0); // calls abs(double);
</pre>
  <p>-- end example]</p>
</div>

<h2 id="sec16.1">16.1 Overloadable declarations <span class="secname">[over.load]</span></h2>
<p><span class="stag" id="sec16.1p1" title="16.1 [over.load]/1">1</span>
全ての関数宣言が多重定義出来るわけではない。
多重定義できないものをここで指定する。
同じスコープに多重定義できない宣言の組を含むプログラムは不適格である。
[註: この制限は、そのスコープにおける明示的宣言同士、または明示宣言と using 宣言により導入される宣言の間に適用される。
(using 指令などに基づく) 名前解決や、 (演算子関数などの) 多重定義解決の過程で考慮される関数の集合に対しては適用されない。 - 註終わり ]
</p>
<p><span class="stag" id="sec16.1p2" title="16.1 [over.load]/2">2</span> 一部の関数宣言は多重定義できない:</p>
<ul>
<li><span class="stag" id="sec16.1p2.1" title="16.1 [over.load]/(2.1)">(2.1)</span>
  戻り値の型、例外指定子 (18.4) を除いて一致する関数宣言は多重定義できない。</li>
<li><span class="stag" id="sec16.1p2.2" title="16.1 [over.load]/(2.2)">(2.2)</span>
  同名で同じ仮引数リスト (11.3.5) を持つメンバ関数宣言は、
  その内の一つが静的メンバ関数宣言 (12.2.3) であるとき、多重定義できない。
  同様に、同名で同じ仮引数リスト、同じテンプレート仮引数リストを持つメンバ関数テンプレート宣言は、
  その内の一つが静的メンバ関数テンプレート宣言であるとき、多重定義できない。
  この規則で仮引数リストを比較する際、多重定義解決のために導入される暗黙オブジェクト仮引数 (16.3.1) の型は考慮されない。
  一方で、静的メンバ関数宣言が含まれない場合は、暗黙オブジェクト仮引数が異なる関数宣言を多重定義できる。
  [ 例: この違いを以下のコードに示す:
  <pre class="agh-prog-cpp">
class X {
  static void f();
  void f();                 // 不適格
  void f() const;           // 不適格
  void f() const volatile;  // 不適格
  void g();
  void g() const;           // OK: 静的な g がないので
  void g() const volatile;  // OK: 静的な g がないので
};
</pre>
  - 例終わり ]
  </li>
<li><span class="stag" id="sec16.1p2.3" title="16.1 [over.load]/(2.3)">(2.3)</span>
  同名・同じ仮引数リストを持つメンバ関数宣言と、
  同名・同じ仮引数リスト・同じテンプレート仮引数リストを持つメンバ関数テンプレートは、
  その内 1 つでも ref 修飾子を持っている場合、
  全てが ref 修飾子を持っていなければ多重定義できない。
  [ 例:
  <pre class="agh-prog-cpp">
class Y {
  void h() &;
  void h() const &; // OK
  void h() &&;      // OK, 全ての宣言が ref 修飾子を持つ。
  void i() &;
  void i() const;   // 不適格。前の i の宣言は ref 修飾子を持つ。
};
  </pre>
  - 例終わり ]
  </li>
</ul>

<div class="en">
  <p><span class="stag" title="16.1 [over.load]/1">1</span>
  Not all function declarations can be overloaded. Those that cannot be overloaded are specified here. A
  program is ill-formed if it contains two such non-overloadable declarations in the same scope. [Note: This
  restriction applies to explicit declarations in a scope, and between such declarations and declarations made
  through a using-declaration (10.3.3). It does not apply to sets of functions fabricated as a result of name
  lookup (e.g., because of using-directives) or overload resolution (e.g., for operator functions). - end note ]
  </p>
  <p><span class="stag" title="16.1 [over.load]/2">2</span>
  Certain function declarations cannot be overloaded:
  </p>
  <ul>
  <li><span class="stag" title="16.1 [over.load]/(2.1)">(2.1)</span>
    Function declarations that differ only in the return type, the exception specification (18.4), or both
    cannot be overloaded.</li>
  <li><span class="stag" title="16.1 [over.load]/(2.2)">(2.2)</span>
    Member function declarations with the same name and the same parameter-type-list (11.3.5) cannot be
    overloaded if any of them is a static member function declaration (12.2.3). Likewise, member function
    template declarations with the same name, the same parameter-type-list, and the same template
    parameter lists cannot be overloaded if any of them is a static member function template declaration.
    The types of the implicit object parameters constructed for the member functions for the purpose of
    overload resolution (16.3.1) are not considered when comparing parameter-type-lists for enforcement
    of this rule. In contrast, if there is no static member function declaration among a set of member
    function declarations with the same name and the same parameter-type-list, then these member function
    declarations can be overloaded if they differ in the type of their implicit object parameter. [Example:
    The following illustrates this distinction:
    <pre class="agh-prog-cpp">
class X {
  static void f();
  void f();                 // ill-formed
  void f() const;           // ill-formed
  void f() const volatile;  // ill-formed
  void g();
  void g() const;           // OK: no static g
  void g() const volatile;  // OK: no static g
};
</pre>
    —end example ]
    </li>
  <li><span class="stag" title="16.1 [over.load]/(2.3)">(2.3)</span> Member function declarations with the same name and the same parameter-type-list (11.3.5) as well as
    member function template declarations with the same name, the same parameter-type-list, and the same
    template parameter lists cannot be overloaded if any of them, but not all, have a ref-qualifier (11.3.5).
    [Example:
    <pre class="agh-prog-cpp">
class Y {
  void h() &;
  void h() const &; // OK
  void h() &&;      // OK, all declarations have a ref-qualifier
  void i() &;
  void i() const;   // ill-formed, prior declaration of i
                    // has a ref-qualifier
};
</pre>
    —end example ]
    </li>
  </ul>
</div>

<p><span class="stag" id="sec16.1p3" title="16.1 [over.load]/3">3</span>
[註: 11.3.5 で指定したように、関数宣言の組が等価な仮引数宣言を持つ場合、
これらは同じ関数を宣言することになるので多重定義することはできない。
</p>
<ul>
<li><span class="stag" id="sec16.1p3.1" title="16.1 [over.load]/(3.1)">(3.1)</span> 等価な typedef された型を使っている点だけ異なる仮引数宣言は等価である。
typedef は独立した型ではなく、ただ他の型の別名を与えるに過ぎない (10.1.3)。[例:
  <pre class="agh-prog-cpp">
typedef int Int;
void f(int i);
void f(Int i);              // OK: f(int) の再宣言
void f(int i) { /* ... */ }
void f(Int i) { /* ... */ } // error: f(int) の再定義
</pre>
  - 例終わり ]
  一方で列挙型は独立した型であり、関数の異なる多重定義を与える。
  [例:
  <pre class="agh-prog-cpp">
enum E { a };
void f(int i) { /* ... */ }
void f(E i) { /* ... */ }
</pre>
  - 例終わり ]
  </li>
<li><span class="stag" id="sec16.1p3.2" title="16.1 [over.load]/(3.2)">(3.2)</span>
一方がポインタ * であり他方が配列 [] であるという点のみ異なる仮引数宣言は等価である。
即ち、配列宣言はポインタ宣言に調整 (11.3.5) されるためである。
2番目以降の配列の次元のみが仮引数の型において意味を持つ (11.3.4)。[例:
  <pre class="agh-prog-cpp">
int f(char*);
int f(char[]);      // f(char*); と同じ
int f(char[7]);     // f(char*); と同じ
int f(char[9]);     // f(char*); と同じ
int g(char(*)[10]);
int g(char[5][10]); // g(char(*)[10]); と同じ
int g(char[7][10]); // g(char(*)[10]); と同じ
int g(char(*)[20]); // g(char(*)[10]); とは異なる。
</pre>
  - 例終わり ]
  </li>
<li><span class="stag" id="sec16.1p3.3" title="16.1 [over.load]/(3.3)">(3.3)</span>
一方が関数型であり他方が同じ関数型へのポインタであるという点のみ異なる仮引数宣言は等価である。
即ち、関数型は関数型へのポインタへと調整 (11.3.5) されるためである。[例:
  <pre class="agh-prog-cpp">
void h(int());
void h(int (*)());      // h(int()) の再宣言
void h(int x()) { }     // h(int()) の定義
void h(int (*x)()) { }  // 不適格: h(int()) の再定義
</pre>
  - 例終わり ]
  </li>
<li><span class="stag" id="sec16.1p3.4" title="16.1 [over.load]/(3.4)">(3.4)</span>
cosnt または volatile が存在するかどうかのみが異なる仮引数宣言は等価である。
即ち、どの関数型が宣言されるか・定義されるか・呼び出されるかを決定する際に、
仮引数型の const/volatile 型指定子は無視される。[例:
  <pre class="agh-prog-cpp">
typedef const int cInt;
int f (int);
int f (const int);          // f(int) の再宣言
int f (int) { /* ... */ }   // f(int) の定義
int f (cInt) { /* ... */ }  // error: f(int) の再定義
</pre>
  - 例終わり ]
  仮引数型の一番外側の const/volatile 型指定子のみが、以下のように無視される。
  仮引数型の内部に埋め込まれた const/volatile 型指定子は、
  関数の多重定義を区別する上で意味を持つ<sup>123</sup>。
  特に、任意の型 <code class="agh-prog-cpp">T</code> について、<code class="agh-prog-cpp">T</code> へのポインタ、
  <code class="agh-prog-cpp">const T</code> へのポインタ、<code class="agh-prog-cpp">volatile T</code> へのポインタは、
  異なる仮引数型と解釈される。
  <code class="agh-prog-cpp">T</code> への参照、<code class="agh-prog-cpp">const T</code> への参照、
  <code class="agh-prog-cpp">volatile T</code> への参照についても同様である。
  </li>
<li><span class="stag" id="sec16.1p3.5" title="16.1 [over.load]/(3.5)">(3.5)</span> 既定の実引数のみが相違する仮引数宣言は等価である。[例:
  以下の例を考慮されたい:
  <pre class="agh-prog-cpp">
void f (int i, int j);
void f (int i, int j = 99); // OK: f(int, int) の再宣言
void f (int i = 88, int j); // OK: f(int, int) の再宣言
void f ();                  // OK: f の多重定義の宣言
void prog () {
  f (1, 2);                 // OK: f(int, int) の呼び出し
  f (1);                    // OK: f(int, int) の呼び出し
  f ();                     // Error: f(int, int) と f() のどちら?
}
</pre>
  - 例終わり ]
  </li>
</ul>
<p>- 註終わり ]</p>
<p><span class="stag" id="footnote123">footnote 123</span>
仮引数型が関数型を含む場合 (例えば仮引数型が関数ポインタの場合)、
その内部関数型の仮引数型において最も外側の const/volatile 型指定子は無視される。</p>
<p class="translation-note">
この部分は Note に過ぎないので細かいことは気にしていないのかもしれないが、色々と記述に穴がある気がする。
例えば、differs only として項目を連ねているが、2つ以上の項目で異なる場合については述べていないので語弊がある。
また、内部関数型の仮引数の const/volatile 無視については述べているが typedef/配列型/関数型 については述べていない。
実際のコンパイラで試すと、期待通り typedef/配列型/関数型 も考慮に入れられるようなので、これはここの記述が分かりにくいだけだ。
思うに、〈仮引数の宣言型〉・〈仮引数の調整型〉・〈型の同一性〉のような概念を導入して統一的に定義するべきなのではという気がする。
</p>

<div class="en">
  <p><span class="stag" title="16.1 [over.load]/3">3</span> [Note: As specified in 11.3.5, function declarations that have equivalent parameter declarations declare the
  same function and therefore cannot be overloaded:
  </p>
  <ul>
  <li><span class="stag" title="16.1 [over.load]/(3.1)">(3.1)</span> Parameter declarations that differ only in the use of equivalent typedef “types” are equivalent. A
    typedef is not a separate type, but only a synonym for another type (10.1.3). [Example:
    <pre class="agh-prog-cpp">
typedef int Int;
void f(int i);
void f(Int i);              // OK: redeclaration of f(int)
void f(int i) { /* ... */ }
void f(Int i) { /* ... */ } // error: redefinition of f(int)
</pre>
    —end example ]
    Enumerations, on the other hand, are distinct types and can be used to distinguish overloaded function
    declarations. [Example:
    <pre class="agh-prog-cpp">
enum E { a };
void f(int i) { /* ... */ }
void f(E i) { /* ... */ }
</pre>
    —end example ]
    </li>
  <li><span class="stag" title="16.1 [over.load]/(3.2)">(3.2)</span> Parameter declarations that differ only in a pointer * versus an array [] are equivalent. That is, the
    array declaration is adjusted to become a pointer declaration (11.3.5). Only the second and subsequent
    array dimensions are significant in parameter types (11.3.4). [Example:
    <pre class="agh-prog-cpp">
int f(char*);
int f(char[]);      // same as f(char*);
int f(char[7]);     // same as f(char*);
int f(char[9]);     // same as f(char*);
int g(char(*)[10]);
int g(char[5][10]); // same as g(char(*)[10]);
int g(char[7][10]); // same as g(char(*)[10]);
int g(char(*)[20]); // different from g(char(*)[10]);
</pre>
    —end example ]
    </li>
  <li><span class="stag" title="16.1 [over.load]/(3.3)">(3.3)</span> Parameter declarations that differ only in that one is a function type and the other is a pointer to
    the same function type are equivalent. That is, the function type is adjusted to become a pointer to
    function type (11.3.5). [Example:
    <pre class="agh-prog-cpp">
void h(int());
void h(int (*)());      // redeclaration of h(int())
void h(int x()) { }     // definition of h(int())
void h(int (*x)()) { }  // ill-formed: redefinition of h(int())
</pre>
    —end example ]
    </li>
  <li><span class="stag" title="16.1 [over.load]/(3.4)">(3.4)</span> Parameter declarations that differ only in the presence or absence of const and/or volatile are
    equivalent. That is, the const and volatile type-specifiers for each parameter type are ignored when
    determining which function is being declared, defined, or called. [Example:
    <pre class="agh-prog-cpp">
typedef const int cInt;
int f (int);
int f (const int);          // redeclaration of f(int)
int f (int) { /* ... */ }   // definition of f(int)
int f (cInt) { /* ... */ }  // error: redefinition of f(int)
</pre>
    —end example ]
    Only the const and volatile type-specifiers at the outermost level of the parameter type specification
    are ignored in this fashion; const and volatile type-specifiers buried within a parameter type
    specification are significant and can be used to distinguish overloaded function declarations. 123 In
    particular, for any type T , “pointer to T ”, “pointer to const T ”, and “pointer to volatile T ” are
    considered distinct parameter types, as are “reference to T ”, “reference to const T ”, and “reference to
    volatile T”.
    </li>
  <li><span class="stag" title="16.1 [over.load]/(3.5)">(3.5)</span> Two parameter declarations that differ only in their default arguments are equivalent. [Example:
    Consider the following:
    <pre class="agh-prog-cpp">
void f (int i, int j);
void f (int i, int j = 99); // OK: redeclaration of f(int, int)
void f (int i = 88, int j); // OK: redeclaration of f(int, int)
void f ();                  // OK: overloaded declaration of f
void prog () {
  f (1, 2);                 // OK: call f(int, int)
  f (1);                    // OK: call f(int, int)
  f ();                     // Error: f(int, int) or f()?
}
</pre>
    —end example ]
    </li>
  </ul>
  <p>—end note ]</p>
  <p><span class="stag">footnote 123</span> When a parameter type includes a function type, such as in the case of a parameter type that is a pointer to function, the
  const and volatile type-specifiers at the outermost level of the parameter type specifications for the inner function type are
  also ignored.</p>
</div>

<h2 id="sec16.2">16.2 Declaration matching <span class="secname">[over.dcl]</span></h2>
<p><span class="stag" id="sec16.2p1" title="16.2 [over.dcl]/1">1</span>
同名の関数宣言は、同じスコープにあり等価な仮引数宣言を持つ時、同一の関数を指す (16.1)。
派生クラスのメンバ関数は、基底クラスの同名のメンバ関数とは別のスコープにある。[例:
</p>
<pre class="agh-prog-cpp">
struct B {
  int f(int);
};
struct D : B {
  int f(const char*);
};
</pre>
<p>この時 <code class="agh-prog-cpp">D::f(const char*)</code> は <code class="agh-prog-cpp">B::f(int)</code> に多重定義を加えるのではなく、これを隠蔽する。</p>
<pre class="agh-prog-cpp">
void h(D* pd) {
  pd->f(1);     // error:
                // D::f(const char*) は B::f(int) を隠蔽する
  pd->B::f(1);  // OK
  pd->f("Ben"); // OK, D::f が呼び出される
}
</pre>
<p>- 例終わり ]</p>
<p class="translation-note">異なる型の変換演算子は「名前」が違うという解釈なのだと思われる。</p>
<p class="translation-note">等価な仮引数宣言を持つが戻り値が異なる関数宣言は、関数型として異なるので多重定義になる (16/1)。
  しかし等価な仮引数宣言を持ち戻り値が異なる関数宣言は、多重定義できない (16.1/(2.1)。
  これにより等価な仮引数宣言を持つだけで、それが同一の関数であることが保証される。</p>
<p class="translation-note">原文には function member という語が出てくるがこれは member function の表記揺れであろう。</p>
<p class="translation-note">テンプレート引数について言及がないのは、この段落の関数宣言とは関数テンプレートは含まないからということだろうか。
  しかし、そうだとすると関数テンプレートの場合に同一の宣言かどうかを判定する記述が与えられず片手落ちである。</p>
<p><span class="stag" id="sec16.2p2" title="16.2 [over.dcl]/2">2</span>
局所的に宣言された関数は、外側のスコープにある関数とは異なるスコープになる。[例:
</p>
<pre class="agh-prog-cpp">
void f(const char*);
void g() {
  extern void f(int);
  f("asdf");                  // error: f(int) は f(const char*) を隠蔽する。
                              // 従って、このスコープに f(const char*) は存在しない。
}
void caller () {
  extern void callee(int, int);
  {
    extern void callee(int);  // callee(int, int) を隠蔽する。
    callee(88, 99);           // error: このスコープには callee(int) しかない。
  }
}
</pre>
<p>- 例終わり ]</p>
<p><span class="stag" id="sec16.2p3" title="16.2 [over.dcl]/3">3</span>
多重定義されたメンバ関数のそれぞれに対して異なるアクセス規則を割り当てることができる。[例:</p>
<pre class="agh-prog-cpp">
class buffer {
private:
  char* p;
  int size;
protected:
  buffer(int s, char* store) { size = s; p = store; }
public:
  buffer(int s) { p = new char[size = s]; }
};
</pre>
<p>- 例終わり ]</p>

<div class="en">
  <p><span class="stag" title="16.2 [over.dcl]/1">1</span>
  Two function declarations of the same name refer to the same function if they are in the same scope and
  have equivalent parameter declarations (16.1). A function member of a derived class is not in the same scope
  as a function member of the same name in a base class. [Example:
  </p>
  <pre class="agh-prog-cpp">
struct B {
  int f(int);
};
struct D : B {
  int f(const char*);
};
</pre>
  <p>Here D::f(const char*) hides B::f(int) rather than overloading it.</p>
  <pre class="agh-prog-cpp">
void h(D* pd) {
  pd->f(1);     // error:
                // D::f(const char*) hides B::f(int)
  pd->B::f(1);  // OK
  pd->f("Ben"); // OK, calls D::f
}
</pre>
  <p>—end example ]</p>
  <p><span class="stag" title="16.2 [over.dcl]/2">2</span>
  A locally declared function is not in the same scope as a function in a containing scope. [Example:
  </p>
  <pre class="agh-prog-cpp">
void f(const char*);
void g() {
  extern void f(int);
  f("asdf");                  // error: f(int) hides f(const char*)
                              // so there is no f(const char*) in this scope
}
void caller () {
  extern void callee(int, int);
  {
    extern void callee(int);  // hides callee(int, int)
    callee(88, 99);           // error: only callee(int) in scope
  }
}
</pre>
  <p>—end example ]</p>
  <p><span class="stag" title="16.2 [over.dcl]/3">3</span>
  Different versions of an overloaded member function can be given different access rules. [Example:</p>
  <pre class="agh-prog-cpp">
class buffer {
private:
  char* p;
  int size;
protected:
  buffer(int s, char* store) { size = s; p = store; }
public:
  buffer(int s) { p = new char[size = s]; }
};
</pre>
  <p>—end example ]</p>
</div>

<h2 id="sec16.3">16.3 Overload resolution <span class="secname">[over.match]</span></h2>
<p><span class="stag" id="sec16.3p1" title="16.3 [over.match]/1">1</span>
多重定義解決は、関数の呼び出しにおいて最適の関数を選択する仕組みである。
実引数の式のリストと、呼び出しの文脈における <i>候補関数</i> の集合が考慮される。
選択の判断材料として、実引数の数、
実引数の仮引数型のリストへの合致度合い、
オブジェクトの暗黙オブジェクト仮引数への合致度合い、
その他の色々の候補関数の性質が用いられる。
[註: 多重定義解決で選択される関数は必ずしもその文脈で適切であるとは限らない。
関数のアクセス可能性などの他の制限によって、その呼び出しが不適格になることがある。 - 註終わり ]
</p>
<p><span class="stag" id="sec16.3p2" title="16.3 [over.match]/2">2</span>
  7つの異なる文脈で多重定義解決が実行される:
</p>
<ul>
<li><span class="stag" id="sec16.3p2.1" title="16.3 [over.match]/(2.1)">(2.1)</span> 関数呼び出し構文の名前で指定された関数の呼び出し (16.3.1.1.1);</li>
<li><span class="stag" id="sec16.3p2.2" title="16.3 [over.match]/(2.2)">(2.2)</span> 関数呼び出し構文の名前で指定されたクラスオブジェクトに対する、
  関数呼び出し演算子、関数ポインタへの変換関数、関数ポインタの参照への変換関数、関数の参照への変換関数の呼び出し (16.3.1.1.2);</li>
<li><span class="stag" id="sec16.3p2.3" title="16.3 [over.match]/(2.3)">(2.3)</span> 式中で参照された演算子の呼び出し (16.3.1.2);</li>
<li><span class="stag" id="sec16.3p2.4" title="16.3 [over.match]/(2.4)">(2.4)</span> クラスオブジェクトの既定初期化または直接初期化 (11.6) に際してのコンストラクタの呼び出し (16.3.1.3);</li>
<li><span class="stag" id="sec16.3p2.5" title="16.3 [over.match]/(2.5)">(2.5)</span> クラスオブジェクトのコピー初期化 (11.6) に際してのユーザ定義の変換の呼び出し (16.3.1.4);</li>
<li><span class="stag" id="sec16.3p2.6" title="16.3 [over.match]/(2.6)">(2.6)</span> クラス型の式による非クラス型のオブジェクトの初期化に際しての変換の呼び出し (16.3.1.5);</li>
<li><span class="stag" id="sec16.3p2.7" title="16.3 [over.match]/(2.7)">(2.7)</span> 参照 (11.6.3) の束縛対象の glvalue またはクラス prvalue を得るための変換関数の呼び出し (16.3.1.6).</li>
</ul>
<p>それぞれの文脈ごとに候補関数の集合と実引数のリストの決定方法が与えられる。
ひとたび候補関数と実引数のリストが与えられれば、最適な関数の選択方法は何れの文脈でも共通である:
</p>
<ul>
<li><span class="stag" id="sec16.3p2.8" title="16.3 [over.match]/(2.8)">(2.8)</span>
  初めに、適切な数の仮引数を持つかどうかなどの条件を満たす候補関数の部分集合として、
  呼び出し可能関数を選別する (16.3.2)。</li>
<li><span class="stag" id="sec16.3p2.9" title="16.3 [over.match]/(2.9)">(2.9)</span>
  次に、実引数をそれぞれ対応する仮引数に合致させるのに使う暗黙変換列 (16.3.3.1) に基づいて、
  最適な呼び出し可能関数を選択する。</li>
</ul>
<p><span class="stag" id="sec16.3p3" title="16.3 [over.match]/3">3</span>
最適な呼び出し可能関数が一意に存在するときに多重定義解決は成功とし、その関数が結果となる。
それ以外の場合は、多重定義解決は失敗であり、その関数呼び出しは不適格である。
多重定義解決が成功したものの最適な呼び出し可能関数がその文脈でアクセス可能 (Clause 14) でないとき、プログラムは不適格である。
</p>

<p class="translation-note">原文 16.3/(2.8) the proper number of arguments は the proper number of parameters の誤りではないか。</p>
<div class="en">
  <p><span class="stag" title="16.3 [over.match]/1">1</span>
  Overload resolution is a mechanism for selecting the best function to call given a list of expressions that are
  to be the arguments of the call and a set of candidate functions that can be called based on the context of
  the call. The selection criteria for the best function are the number of arguments, how well the arguments
  match the parameter-type-list of the candidate function, how well (for non-static member functions) the
  object matches the implicit object parameter, and certain other properties of the candidate function. [Note:
  The function selected by overload resolution is not guaranteed to be appropriate for the context. Other
  restrictions, such as the accessibility of the function, can make its use in the calling context ill-formed. —end
  note ]
  </p>
  <p><span class="stag" title="16.3 [over.match]/2">2</span>
  Overload resolution selects the function to call in seven distinct contexts within the language:
  </p>
  <ul>
  <li><span class="stag" title="16.3 [over.match]/(2.1)">(2.1)</span> invocation of a function named in the function call syntax (16.3.1.1.1);</li>
  <li><span class="stag" title="16.3 [over.match]/(2.2)">(2.2)</span> invocation of a function call operator, a pointer-to-function conversion function,
    a reference-to-pointer-to-function conversion function, or a reference-to-function conversion function on a class object named
    in the function call syntax (16.3.1.1.2);</li>
  <li><span class="stag" title="16.3 [over.match]/(2.3)">(2.3)</span> invocation of the operator referenced in an expression (16.3.1.2);</li>
  <li><span class="stag" title="16.3 [over.match]/(2.4)">(2.4)</span> invocation of a constructor for default- or direct-initialization (11.6) of a class object (16.3.1.3);</li>
  <li><span class="stag" title="16.3 [over.match]/(2.5)">(2.5)</span> invocation of a user-defined conversion for copy-initialization (11.6) of a class object (16.3.1.4);</li>
  <li><span class="stag" title="16.3 [over.match]/(2.6)">(2.6)</span> invocation of a conversion function for initialization of an object of a non-class type from an expression
    of class type (16.3.1.5); and</li>
  <li><span class="stag" title="16.3 [over.match]/(2.7)">(2.7)</span> invocation of a conversion function for conversion to a glvalue or class prvalue to which a reference (11.6.3)
    will be directly bound (16.3.1.6).</li>
  </ul>
  <p>Each of these contexts defines the set of candidate functions and the list of arguments in its own unique way.
  But, once the candidate functions and argument lists have been identified, the selection of the best function
  is the same in all cases:
  </p>
  <ul>
  <li><span class="stag" title="16.3 [over.match]/(2.8)">(2.8)</span> First, a subset of the candidate functions (those that have the proper number of arguments and meet
    certain other conditions) is selected to form a set of viable functions (16.3.2).</li>
  <li><span class="stag" title="16.3 [over.match]/(2.9)">(2.9)</span> Then the best viable function is selected based on the implicit conversion sequences (16.3.3.1) needed
    to match each argument to the corresponding parameter of each viable function.</li>
  </ul>
  <p><span class="stag" title="16.3 [over.match]/3">3</span>
  If a best viable function exists and is unique, overload resolution succeeds and produces it as the result.
  Otherwise overload resolution fails and the invocation is ill-formed. When overload resolution succeeds,
  and the best viable function is not accessible (Clause 14) in the context in which it is used, the program is
  ill-formed.
  </p>
</div>

<h3>16.3.1 Candidate functions and argument lists <span class="secname">[over.match.funcs]</span></h3>
<h4>16.3.1.1 Function call syntax <span class="secname">[over.match.call]</span></h4>
<h5>16.3.1.1.1 Call to named function <span class="secname">[over.call.func]</span></h5>
<h5>16.3.1.1.2 Call to object of class type <span class="secname">[over.call.object]</span></h5>
<h4>16.3.1.2 Operators in expressions <span class="secname">[over.match.oper]</span></h4>
<h4>16.3.1.3 Initialization by constructor <span class="secname">[over.match.ctor]</span></h4>
<h4>16.3.1.4 Copy-initialization of class by user-defined conversion <span class="secname">[over.match.copy]</span></h4>
<h4>16.3.1.5 Initialization by conversion function <span class="secname">[over.match.conv]</span></h4>
<h4>16.3.1.6 Initialization by conversion function for direct reference binding <span class="secname">[over.match.ref]</span></h4>
<h4>16.3.1.7 Initialization by list-initialization <span class="secname">[over.match.list]</span></h4>
<h4>16.3.1.8 Class template argument deduction <span class="secname">[over.match.class.deduct]</span></h4>
<h3 id="sec16.3.2">16.3.2 Viable functions <span class="secname">[over.match.viable]</span></h3>
<p><span class="stag" id="sec16.3.2p1" title="16.3.2 [over.match.viable]/1">1</span>
現在の文脈に対して候補関数の集合を求めた後 (16.3.1)、その中から呼び出し可能関数の集合が選ばれる。
実引数の変換列 (16.3) を比べることによって、呼び出し可能関数の中からできるだけ実引数が合致する最適な関数が選択される。
呼び出し可能関数の選択では、(変換列の優先度を除く) 実引数と関数の仮引数の関係が考慮される。
</p>
<p><span class="stag" id="sec16.3.2p2" title="16.3.2 [over.match.viable]/2">2</span>
先ず、候補関数が呼び出し可能関数であるためには、
実引数の数に対して仮引数が十分な数ある必要がある。
</p>
<ul>
<li><span class="stag" id="sec16.3.2p2.1" title="16.3.2 [over.match.viable]/(2.1)">(2.1)</span> <i>m</i> 個の実引数があるとき、丁度 <i>m</i> 個の仮引数を持つ候補関数は呼び出し可能である。</li>
<li><span class="stag" id="sec16.3.2p2.2" title="16.3.2 [over.match.viable]/(2.2)">(2.2)</span>
  <i>m</i> 個より少ない仮引数を持つ候補関数は、仮引数リスト (11.3.5) に省略記号を持つ時に限り呼び出し可能である。
  多重定義解決の過程で、対応する仮引数のない実引数は「省略記号に一致する」として扱う (16.3.3.1.3)。</li>
<li><span class="stag" id="sec16.3.2p2.3" title="16.3.2 [over.match.viable]/(2.3)">(2.3)</span>
  <i>m</i> 個より多くの仮引数を持つ候補関数は、<i>m+1</i> 個目の仮引数が既定の実引数 (11.3.6) を持つときに限り呼び出し可能である<sup>130</sup>。
  多重定義解決の過程では、仮引数リストは丁度 <i>m</i> 個の仮引数を持つように右端を切除して用いる。</li>
</ul>
<p><span class="stag" id="sec16.3.2p3" title="16.3.2 [over.match.viable]/3">3</span>
次に、<code class="agh-prog-cpp">F</code> が呼び出し可能関数であるためには、
それぞれの実引数を対応する <code class="agh-prog-cpp">F</code> の仮引数に変換する暗黙変換列 (16.3.3.1) が存在する必要がある。
仮引数が参照型の場合は、暗黙変換列には参照の束縛も含まれる。
従って、非 const 左辺値参照が rvalue に束縛できないこと、
また右辺値参照が lvalue に束縛できないことは、
関数の呼び出し可能性に影響を与える (16.3.3.1.4)。
</p>
<p><span class="stag" id="footenote130">foonote 130</span>
この時、11.3.6 により <i>m+1</i> 個目以降の仮引数も既定の実引数を持っている。
</p>
<p class="translation-note">
原文 viable functions はここでは<i>呼び出し可能関数</i>と訳すことにした。
JIS C++ では<i>二次候補関数</i>と訳していることに注意する。
</p>
<div class="en">
  <p><span class="stag" title="16.3.2 [over.match.viable]/1">1</span>
  From the set of candidate functions constructed for a given context (16.3.1), a set of viable functions is
  chosen, from which the best function will be selected by comparing argument conversion sequences for the
  best fit (16.3.3). The selection of viable functions considers relationships between arguments and function
  parameters other than the ranking of conversion sequences.
  </p>
  <p><span class="stag" title="16.3.2 [over.match.viable]/2">2</span>
  First, to be a viable function, a candidate function shall have enough parameters to agree in number with
  the arguments in the list.
  </p>
  <ul>
  <li><span class="stag" title="16.3.2 [over.match.viable]/(2.1)">(2.1)</span> If there are m arguments in the list, all candidate functions having exactly m parameters are viable.</li>
  <li><span class="stag" title="16.3.2 [over.match.viable]/(2.2)">(2.2)</span> A candidate function having fewer than m parameters is viable only if it has an ellipsis in its parameter
    list (11.3.5). For the purposes of overload resolution, any argument for which there is no corresponding
    parameter is considered to “match the ellipsis” (16.3.3.1.3) .</li>
  <li><span class="stag" title="16.3.2 [over.match.viable]/(2.3)">(2.3)</span> A candidate function having more than m parameters is viable only if the (m+1)-st parameter has a
    default argument (11.3.6). 130 For the purposes of overload resolution, the parameter list is truncated
    on the right, so that there are exactly m parameters.</li>
  </ul>
  <p><span class="stag" title="16.3.2 [over.match.viable]/3">3</span>
  Second, for F to be a viable function, there shall exist for each argument an implicit conversion se-
  quence (16.3.3.1) that converts that argument to the corresponding parameter of F . If the parameter
  has reference type, the implicit conversion sequence includes the operation of binding the reference, and the
  fact that an lvalue reference to non- const cannot be bound to an rvalue and that an rvalue reference cannot
  be bound to an lvalue can affect the viability of the function (see 16.3.3.1.4).
  </p>
  <p><span class="stag">foonote 130</span>
  According to 11.3.6, parameters following the (m+1)-st parameter must also have default arguments.
  </p>
</div>

<h3 id="sec16.3.3">16.3.3 Best viable function <span class="secname">[over.match.best]</span></h3>
<p><span class="stag" id="sec16.3.3p1" title="16.3.3 [over.match.best]/1">1</span>
<span class="tcomment">呼び出し可能関数 <code class="agh-prog-cpp">F</code> に対して</span>
<span class="ICS">ICS<i>i</i>(<code class="agh-prog-cpp">F</code>)</span> を次のように定義する:</p>
<ul>
<li><span class="stag" id="sec16.3.3p1.1" title="16.3.3 [over.match.best]/(1.1)">(1.1)</span>
  <code class="agh-prog-cpp">F</code> が静的メンバ関数の場合は、任意の関数 <code class="agh-prog-cpp">G</code> について、
  <span class="ICS">ICS<i>1</i>(<code class="agh-prog-cpp">F</code>)</span> は
  <span class="ICS">ICS<i>1</i>(<code class="agh-prog-cpp">G</code>)</span> に比べて良くも悪くもなく、
  また <span class="ICS">ICS<i>1</i>(<code class="agh-prog-cpp">G</code>)</span> は
  <span class="ICS">ICS<i>1</i>(<code class="agh-prog-cpp">F</code>)</span> に比べて良くも悪くもない<sup>131</sup>。
  それ以外の場合は、</li>
<li><span class="stag" id="sec16.3.3p1.2" title="16.3.3 [over.match.best]/(1.2)">(1.2)</span>
  <span class="ICS">ICS<i>i</i>(<code class="agh-prog-cpp">F</code>)</span> は、
  <i>i</i> 番目の実引数から <code class="agh-prog-cpp">F</code> の <i>i</i> 番目の仮引数型への暗黙変換列を表す。
  16.3.3.1 で暗黙変換列を定義し、16.3.3.2 で或る暗黙変換列が他の暗黙変換列と比べて良いか悪いかを定義する。
  </li>
</ul>
<p>その上で、次が満たされるときに、
呼び出し可能関数 <code class="agh-prog-cpp">F1</code> が
<code class="agh-prog-cpp">F2</code> よりも良いと定義する。
即ち、全ての実引数 <i>i</i> について
<span class="ICS">ICS<i>i</i>(<code class="agh-prog-cpp">F1</code>)</span> が
<span class="ICS">ICS<i>i</i>(<code class="agh-prog-cpp">F2</code>)</span> より悪くなく、
かつ</p>
<ul>
<li><span class="stag" id="sec16.3.3p1.3" title="16.3.3 [over.match.best]/(1.3)">(1.3)</span>
  或る実引数 <i>j</i> について
  <span class="ICS">ICS<i>j</i>(<code class="agh-prog-cpp">F1</code>)</span> が
  <span class="ICS">ICS<i>j</i>(<code class="agh-prog-cpp">F2</code>)</span> より良いか、
  そうでなければ</li>
<li><span class="stag" id="sec16.3.3p1.4" title="16.3.3 [over.match.best]/(1.4)">(1.4)</span>
  ユーザ定義変換による初期化の文脈 (11.6, 16.3.1.5, 16.3.1.6) で、
  <code class="agh-prog-cpp">F1</code> の戻り値の型から目的の型 (初期化されるオブジェクトの型) への標準変換列が、
  <code class="agh-prog-cpp">F2</code> の戻り値の型から目的の型への標準変換列より良い [例:
<pre class="agh-prog-cpp">
struct A {
  A();
  operator int();
  operator double();
} a;
int i = a;    // 変換の必要のない a.operator int() の方が、
              // 後で int に変換する必要のある a.operator double() よりも良い。
float x = a;  // 曖昧: どちらの選択肢も変換を必要とし、
              // 何れかが他方より良いということはない。
</pre>
  - 例終わり ] か、そうでなければ</li>
<li><span class="stag" id="sec16.3.3p1.5" title="16.3.3 [over.match.best]/(1.5)">(1.5)</span>
  関数の参照への変換関数を通して参照を直接の束縛により初期化する文脈 (16.3.1.6) で、
  <code class="agh-prog-cpp">F1</code> が初期化される参照と同じ種類の参照 (つまり右辺値参照または左辺値参照) であり、
  <code class="agh-prog-cpp">F2</code> がそうでない [例:
<pre class="agh-prog-cpp">
template &lt;class T&gt; struct A {
  operator T&amp;();  // #1
  operator T&amp;&amp;(); // #2
};
typedef int Fn();
A&lt;Fn&gt; a;
Fn&amp; lf = a;       // #1 が呼び出される
Fn&amp;&amp; rf = a;      // #2 が呼び出される
</pre>
  - 例終わり ] か、そうでなければ</li>
<li><span class="stag" id="sec16.3.3p1.6" title="16.3.3 [over.match.best]/(1.6)">(1.6)</span>
  <code class="agh-prog-cpp">F1</code> が関数テンプレートの特殊化ではなく、
  <code class="agh-prog-cpp">F2</code> が関数テンプレートの特殊化であるか、
  そうでなければ</li>
<li><span class="stag" id="sec16.3.3p1.7" title="16.3.3 [over.match.best]/(1.7)">(1.7)</span>
  <code class="agh-prog-cpp">F1</code> と <code class="agh-prog-cpp">F2</code> が関数テンプレートの特殊化であり、
  17.5.6.2 の半順序規則に基いて
  <code class="agh-prog-cpp">F1</code> の関数テンプレートが
  <code class="agh-prog-cpp">F2</code> の関数テンプレートに比べてより特殊であるか、
  そうでなければ
  </li>
<li><span class="stag" id="sec16.3.3p1.8" title="16.3.3 [over.match.best]/(1.8)">(1.8)</span>
  <code class="agh-prog-cpp">F1</code> が deduction-guide (16.3.1.8) によって生成され、
  <code class="agh-prog-cpp">F2</code> がそうでないか、
  そうでなければ</li>
<li><span class="stag" id="sec16.3.3p1.9" title="16.3.3 [over.match.best]/(1.9)">(1.9)</span>
  <code class="agh-prog-cpp">F1</code> が copy deduction candidate (16.3.1.8) で
  <code class="agh-prog-cpp">F2</code> がそうでないか、
  そうでなければ</li>
<li><span class="stag" id="sec16.3.3p1.10" title="16.3.3 [over.match.best]/(1.10)">(1.10)</span>
  <code class="agh-prog-cpp">F1</code> が非テンプレートコンストラクタで
  <code class="agh-prog-cpp">F2</code> がコンストラクタテンプレートによって生成される。[例:
  <pre class="agh-prog-cpp">
template &lt;class T&gt; struct A {
  using value_type = T;
  A(value_type);    // #1
  A(const A&amp;);      // #2
  A(T, T, int);     // #3
  template&lt;class U&gt;
    A(int, T, U);   // #4
  // #5 を copy deduction candidate A(A) とする。
};

A x(1, 2, 3);       // 非テンプレートコンストラクタから生成された #3 が使われる

template &lt;class T&gt;
A(T) -&gt; A&lt;T&gt;;       // #6, #5 に比べて特殊でない

A a(42);            // #6 で A&lt;int&gt; と推論され #1 で初期化される
A b = a;            // #5 で A&lt;int&gt; と推論され #2 で初期化される

template &lt;class T&gt;
A(A&lt;T&gt;) -&gt; A&lt;A&lt;T&gt;&gt;; // #7, #5 と同程度に特殊

A b2 = a;           // #7 で A&lt;A&lt;int&gt;&gt; と推論され #1 で初期化される
</pre>
  - 例終わり ]
</li>
</ul>
<p class="translation-note">#7 の振る舞いについて確認する必要がある</p>
<p class="translation-note">上記の二項関係は「より良い」という字面に反していいかげんな関係である。
つまり <code>better(F, G) := P1(F, G) || ... || Pn(F, G)</code>
(但し <code>P1, ..., Pn</code> は前順序を与える?) の形式をしているが、
この時 <code>better(F, G)</code> と <code>worse(F, G) := better(G, F)</code> は排他的にはなっていない。
つまり、互いに他方よりも良くかつ悪いという場合がある (全順序律を満たさない)。
もちろん、互いに他方より良くも悪くもないという場合もある (反対称律を満たさない)。
推移率はどうか? うーん…もう少し後でちゃんと考える必要がある…。
</p>
<p><span class="stag" id="sec16.3.3p2" title="16.3.3 [over.match.best]/2">2</span>
他の全ての呼び出し可能関数よりも良い呼び出し可能関数が一意に存在する場合、
それが多重定義解決によって選ばれる。それ以外の場合はその呼出は不適格である<sup>132</sup>。 [例:
</p>
<pre class="agh-prog-cpp">
void Fcn(const int*, short);
void Fcn(int*, int);

int i;
short s = 0;

void f() {
  Fcn(&amp;i, s);     // 曖昧。何故なら &amp;i → int* は &amp;i → const int* より良く、
                  // 同時に s → short が s → int より良い。

  Fcn(&amp;i, 1L);    // Fcn(int*, int) が呼び出される。何故なら &amp;i → int* は &amp;i → const int* より良く、
                  // 1L → short と 1L → int はどちらが良いわけでもない。

  Fcn(&amp;i, ’c’); // Fcn(int*, int) が呼び出される。何故なら &amp;i → int* は &amp;i → const int* より良く、
                  // c → int は c → short より良い。
}
</pre>
<p>- 例終わり ]</p>
<p><span class="stag" id="sec16.3.3p3" title="16.3.3 [over.match.best]/3">3</span>
最良の呼び出し可能関数が複数の宣言を持つ関数に決まった場合、
関数を呼び出し可能にした或る既定の実引数を
2つ以上の宣言 (または using 宣言の場合、それが指し示す宣言) が指定したとき
プログラムは不適格である。[例:
</p>
<pre class="agh-prog-cpp">
namespace A {
  extern "C" void f(int = 5);
}
namespace B {
  extern "C" void f(int = 5);
}

using A::f;
using B::f;

void use() {
  f(3); // OK, default argument was not used for viability
  f();  // Error: found default argument twice
}
</pre>
<p>- 例終わり ]</p>
<p class="translation-note">
原文 a default argument that made the function viable は微妙。
Viable functions の所では <i>m+1</i> 番目の既定の実引数についてしか述べられていない。
しかし、ここでは <i>m+1</i> 番目以降の全ての実引数について述べているはずである
(不定冠詞 a が用いられているのはそれを示唆する)。
</p>
<p class="translation-note"><code class="agh-prog-cpp">extern "C"</code> がついているので、
<code class="agh-prog-cpp">A::f</code> と <code class="agh-prog-cpp">B::f</code> は同一の関数?
と思ったがそのようなことは何処かに書かれていただろうか?
</p>
<p><span class="stag" id="footnote131">footnote 131</span>
関数が静的メンバ関数の場合は、第一引数 (つまり暗黙オブジェクト実引数) は、
その関数が他の関数より良いか悪いかの判断には寄与しないことを表す。
</p>
<p><span class="stag" id="footnote132">footnote 132</span>
最適な呼び出し可能関数の決定アルゴリズムは呼び出し可能関数の数について線形時間になる。
単純な勝ち抜き戦によってどの対戦相手と比べても悪くない関数 <code class="agh-prog-cpp">W</code> を決める。
<code class="agh-prog-cpp">W</code> と直接対戦しなかった関数 <code class="agh-prog-cpp">F</code> が
<code class="agh-prog-cpp">W</code> より悪くないという可能性もあるが、
<span class="tcomment"><code class="agh-prog-cpp">F</code> が最終的に残っていないということから</span>
勝ち抜き戦の途中で <code class="agh-prog-cpp">F</code> が
<code class="agh-prog-cpp">F</code> より悪くない別の関数 <code class="agh-prog-cpp">G</code> と対戦しているはずなので、
<code class="agh-prog-cpp">F</code> は最良の呼び出し可能関数にはなりえない。
従って <code class="agh-prog-cpp">W</code> が最良の呼び出し可能関数であるか、そのようなものは存在しないかである。
そこで呼び出し可能関数に対して2回目の走査を行い
<code class="agh-prog-cpp">W</code> が他の全ての呼び出し可能関数より良いかどうかを確かめる。
</p>
<p class="translation-note">より良いか悪いかは変な二項関係なので2回目の走査は必要である。</p>

<div class="en">
  <p><span class="stag" title="16.3.3 [over.match.best]/1">1</span> Define ICSi(F) as follows:</p>
  <ul>
  <li><span class="stag" title="16.3.3 [over.match.best]/(1.1)">(1.1)</span>
    If F is a static member function, ICS1( F ) is defined such that ICS1( F ) is neither better nor worse than
    ICS1( G ) for any function G , and, symmetrically, ICS1( G ) is neither better nor worse than ICS1( F ); 131
    otherwise,</li>
  <li><span class="stag" title="16.3.3 [over.match.best]/(1.2)">(1.2)</span>
    let ICSi( F ) denote the implicit conversion sequence that converts the i-th argument in the list to the
    type of the i-th parameter of viable function F . 16.3.3.1 defines the implicit conversion sequences and
    16.3.3.2 defines what it means for one implicit conversion sequence to be a better conversion sequence
    or worse conversion sequence than another.</li>
  </ul>
  <p>Given these definitions, a viable function F1 is defined to be a better function than another viable function
  F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>
  <ul>
  <li><span class="stag" title="16.3.3 [over.match.best]/(1.3)">(1.3)</span> for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that,</li>
  <li><span class="stag" title="16.3.3 [over.match.best]/(1.4)">(1.4)</span>
    the context is an initialization by user-defined conversion (see 11.6, 16.3.1.5, and 16.3.1.6) and the
    standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the
    entity being initialized) is a better conversion sequence than the standard conversion sequence from the
    return type of F2 to the destination type [Example:
  <pre class="agh-prog-cpp">
struct A {
  A();
  operator int();
  operator double();
} a;
int i = a;    // a.operator int() followed by no conversion is better than
              // a.operator double() followed by a conversion to int
float x = a;  // ambiguous: both possibilities require conversions,
              // and neither is better than the other
</pre>
    —end example ] or, if not that,</li>
  <li><span class="stag" title="16.3.3 [over.match.best]/(1.5)">(1.5)</span>
    the context is an initialization by conversion function for direct reference binding (16.3.1.6) of a reference
    to function type, the return type of F1 is the same kind of reference (i.e. lvalue or rvalue) as the
    reference being initialized, and the return type of F2 is not [Example:
  <pre class="agh-prog-cpp">
template &lt;class T&gt; struct A {
  operator T&amp;();  // #1
  operator T&amp;&amp;(); // #2
};
typedef int Fn();
A&lt;Fn&gt; a;
Fn&amp; lf = a;       // calls #1
Fn&amp;&amp; rf = a;      // calls #2
</pre>
    —end example ] or, if not that,</li>
  <li><span class="stag" title="16.3.3 [over.match.best]/(1.6)">(1.6)</span> F1 is not a function template specialization and F2 is a function template specialization, or, if not that,</li>
  <li><span class="stag" title="16.3.3 [over.match.best]/(1.7)">(1.7)</span> F1 and F2 are function template specializations, and the function template for F1 is more specialized
    than the template for F2 according to the partial ordering rules described in 17.5.6.2, or, if not that,</li>
  <li><span class="stag" title="16.3.3 [over.match.best]/(1.8)">(1.8)</span> F1 is generated from a deduction-guide (16.3.1.8) and F2 is not, or, if not that,</li>
  <li><span class="stag" title="16.3.3 [over.match.best]/(1.9)">(1.9)</span> F1 is the copy deduction candidate (16.3.1.8) and F2 is not, or, if not that,</li>
  <li><span class="stag" title="16.3.3 [over.match.best]/(1.10)">(1.10)</span> F1 is generated from a non-template constructor and F2 is generated from a constructor template. [Example:
    <pre class="agh-prog-cpp">
template &lt;class T&gt; struct A {
  using value_type = T;
  A(value_type);    // #1
  A(const A&amp;);      // #2
  A(T, T, int);     // #3
  template&lt;class U&gt;
    A(int, T, U);   // #4
  // #5 is the copy deduction candidate, A(A)
};

A x(1, 2, 3);       // uses #3, generated from a non-template constructor

template &lt;class T&gt;
A(T) -&gt; A&lt;T&gt;;       // #6, less specialized than #5

A a(42);            // uses #6 to deduce A&lt;int&gt; and #1 to initialize
A b = a;            // uses #5 to deduce A&lt;int&gt; and #2 to initialize

template &lt;class T&gt;
A(A&lt;T&gt;) -&gt; A&lt;A&lt;T&gt;&gt;; // #7, as specialized as #5

A b2 = a;           // uses #7 to deduce A&lt;A&lt;int&gt;&gt; and #1 to initialize
</pre>
    —end example ]
  </li>
  </ul>
  <p><span class="stag" title="16.3.3 [over.match.best]/2">2</span>
  If there is exactly one viable function that is a better function than all other viable functions, then it is the
  one selected by overload resolution; otherwise the call is ill-formed. <sup>132</sup> [Example:
  </p>
  <pre class="agh-prog-cpp">
void Fcn(const int*, short);
void Fcn(int*, int);

int i;
short s = 0;

void f() {
  Fcn(&amp;i, s);     // is ambiguous because &amp;i → int* is better than &amp;i → const int*
                  // but s → short is also better than s → int

  Fcn(&amp;i, 1L);    // calls Fcn(int*, int), because &amp;i → int* is better than &amp;i → const int*
                  // and 1L → short and 1L → int are indistinguishable

  Fcn(&amp;i, ’c’); // calls Fcn(int*, int), because &amp;i → int* is better than &amp;i → const int*
                  // and c → int is better than c → short
}
</pre>
  <p>—end example ]</p>
  <p><span class="stag" title="16.3.3 [over.match.best]/3">3</span>
  If the best viable function resolves to a function for which multiple declarations were found, and if at least
  two of these declarations — or the declarations they refer to in the case of using-declarations — specify a
  default argument that made the function viable, the program is ill-formed. [Example:
  </p>
  <pre class="agh-prog-cpp">
namespace A {
  extern "C" void f(int = 5);
}
namespace B {
  extern "C" void f(int = 5);
}

using A::f;
using B::f;

void use() {
  f(3); // OK, default argument was not used for viability
  f();  // Error: found default argument twice
}
</pre>
  <p>—end example ]</p>
  <p><span class="stag">footnote 131</span>
  If a function is a static member function, this definition means that the first argument, the implied object argument, has no
  effect in the determination of whether the function is better or worse than any other function.
  </p>
  <p><span class="stag">footnote 132</span>
  The algorithm for selecting the best viable function is linear in the number of viable functions. Run a simple tournament
  to find a function W that is not worse than any opponent it faced. Although another function F that W did not face might be at
  least as good as W , F cannot be the best function because at some point in the tournament F encountered another function G
  such that F was not better than G . Hence, W is either the best function or there is no best function. So, make a second pass over
  the viable functions to verify that W is better than all other functions.
  </p>
</div>

<h4>16.3.3.1 Implicit conversion sequences <span class="secname">[over.best.ics]</span></h4>
<h5>16.3.3.1.1 Standard conversion sequences <span class="secname">[over.ics.scs]</span></h5>
<h5>16.3.3.1.2 User-defined conversion sequences <span class="secname">[over.ics.user]</span></h5>
<h5>16.3.3.1.3 Ellipsis conversion sequences <span class="secname">[over.ics.ellipsis]</span></h5>
<h5>16.3.3.1.4 Reference binding <span class="secname">[over.ics.ref]</span></h5>
<h5>16.3.3.1.5 List-initialization sequence <span class="secname">[over.ics.list]</span></h5>
<h4>16.3.3.2 Ranking implicit conversion sequences <span class="secname">[over.ics.rank]</span></h4>
<h2>16.4 Address of overloaded function [over.over]</h2>
<h2>16.5 Overloaded operators [over.oper]</h2>
<h2>16.6 Built-in operators [over.built]</h2>

<h1>17 Templates <span class="secname">[temp]</span></h1>
<p>略</p>
<h1>18 Exception handling <span class="secname">[except]</span></h1>
<p>略</p>
<h1>19 Preprocessing Directives <span class="secname">[cpp]</span></h1>
<p>略</p>
</body>
</html>
